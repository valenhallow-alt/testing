-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867"
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)

-- =========================
-- Egg Stats tab (was "Main")
-- =========================

local EggTab = Window:CreateTab("Egg Stats", 4483362458) -- Title, Image
local EggSection = EggTab:CreateSection("Egg Information")

-- Labels to display egg info
local ParentLabel = EggTab:CreateLabel("Parent: N/A", 4483362458, Color3.fromRGB(255,255,255), false)
local PriceLabel = EggTab:CreateLabel("Price: N/A", 4483362458, Color3.fromRGB(255,255,255), false)
local RarityLabel = EggTab:CreateLabel("Rarity: N/A", 4483362458, Color3.fromRGB(255,255,255), false)
local VarietyLabel = EggTab:CreateLabel("Variety: N/A", 4483362458, Color3.fromRGB(255,255,255), false)

-- Helper: safely read a property from a container (handles Value objects, TextLabels, StringValues, etc.)
local function readContainerField(container, fieldName)
    if not container then return nil end
    local ok, result = pcall(function()
        local obj = container:FindFirstChild(fieldName)
        if not obj then return nil end
        if obj:IsA("StringValue") or obj:IsA("IntValue") or obj:IsA("NumberValue") or obj:IsA("BoolValue") then
            return obj.Value
        end
        if obj:IsA("TextLabel") or obj:IsA("TextBox") then
            return obj.Text
        end
        if obj.Value ~= nil then
            return obj.Value
        end
        if obj.Text ~= nil then
            return obj.Text
        end
        return tostring(obj)
    end)
    if ok then return result end
    return nil
end

-- Find the current Eggtag and its parent name
local function findEggTag()
    for _, child in ipairs(workspace:GetChildren()) do
        local eggtag = child:FindFirstChild("Eggtag")
        if eggtag then
            return eggtag, child.Name
        end
    end
    for _, desc in ipairs(workspace:GetDescendants()) do
        if desc.Name == "Eggtag" then
            local parent = desc.Parent
            return desc, parent and parent.Name or nil
        end
    end
    return nil, nil
end

-- Update UI labels from a given eggtag instance
local function updateEggInfo(eggtag, parentName)
    if not eggtag then
        ParentLabel:Set("Parent: N/A")
        PriceLabel:Set("Price: N/A")
        RarityLabel:Set("Rarity: N/A")
        VarietyLabel:Set("Variety: N/A")
        return
    end

    local container = eggtag:FindFirstChild("Container") or eggtag
    local price = readContainerField(container, "Price") or "N/A"
    local rarity = readContainerField(container, "Rarity") or "N/A"
    local variety = readContainerField(container, "Variety") or "N/A"

    ParentLabel:Set("Parent: " .. (tostring(parentName) or "N/A"))
    PriceLabel:Set("Price: " .. tostring(price))
    RarityLabel:Set("Rarity: " .. tostring(rarity))
    VarietyLabel:Set("Variety: " .. tostring(variety))
end

-- Track current eggtag and parent
local currentEggTag = nil
local currentParentName = nil

local function refreshCurrentEgg()
    local eggtag, parentName = findEggTag()
    if eggtag ~= currentEggTag or parentName ~= currentParentName then
        currentEggTag = eggtag
        currentParentName = parentName
        updateEggInfo(currentEggTag, currentParentName)
    else
        updateEggInfo(currentEggTag, currentParentName)
    end
end

-- Listen for workspace changes to update egg info quickly
workspace.DescendantAdded:Connect(function(desc)
    if desc.Name == "Eggtag" then
        wait(0.05)
        pcall(refreshCurrentEgg)
    end
end)
workspace.DescendantRemoving:Connect(function(desc)
    if desc.Name == "Eggtag" then
        wait(0.05)
        pcall(refreshCurrentEgg)
    end
end)

-- Bind listeners to container children/values for faster updates
local function bindContainerListeners(eggtag)
    if not eggtag then return end
    local container = eggtag:FindFirstChild("Container") or eggtag
    if container._rayfield_listeners then
        for _, conn in ipairs(container._rayfield_listeners) do
            pcall(function() conn:Disconnect() end)
        end
    end
    container._rayfield_listeners = {}

    local added = container.ChildAdded:Connect(function() pcall(refreshCurrentEgg) end)
    local removed = container.ChildRemoved:Connect(function() pcall(refreshCurrentEgg) end)
    table.insert(container._rayfield_listeners, added)
    table.insert(container._rayfield_listeners, removed)

    for _, obj in ipairs(container:GetChildren()) do
        if obj:IsA("StringValue") or obj:IsA("NumberValue") or obj:IsA("IntValue") or obj:IsA("BoolValue") or obj:IsA("TextLabel") or obj:IsA("TextBox") then
            local conn = obj.Changed:Connect(function() pcall(refreshCurrentEgg) end)
            table.insert(container._rayfield_listeners, conn)
        end
    end
end

-- Periodic poll as a fallback
spawn(function()
    while true do
        pcall(function()
            refreshCurrentEgg()
            bindContainerListeners(currentEggTag)
        end)
        wait(1)
    end
end)

-- =========================
-- Main tab (new) + Auto Buy toggle moved here
-- =========================

local MainTab = Window:CreateTab("Main", 4483362458)
local MainSection = MainTab:CreateSection("Automation")

-- State used to ensure we don't request a new egg until the current one is confirmed purchased
local lastPurchaseConfirmed = true
local purchaseTimeout = 6 -- seconds to wait for confirmation after purchase attempt

-- Helper: build id from parent name (customize mapping if needed)
local function buildEntityIdFromParent(parentName)
    if not parentName then return nil end
    -- Normalize: lowercase and replace spaces with underscores
    local normalized = tostring(parentName):gsub("%s+", "_")
    normalized = normalized:gsub("[^%w_]", "") -- remove non-alphanumeric/underscore
    normalized = string.lower(normalized)
    -- Construct id pattern: entity_<normalized>_egg
    return "entity_" .. normalized .. "_egg"
end

-- Helper: fire _requestEgg remote
local function fireRequestEgg()
    local ok, err = pcall(function()
        local args = {
            {
                __raw = true,
                data = {}
            }
        }
        local inst = game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Internals"):WaitForChild("Skeleton"):WaitForChild("Conduit"):WaitForChild("Instances")
        local req = inst:FindFirstChild("_requestEgg")
        if req and req.FireServer then
            req:FireServer(unpack(args))
        else
            error("_requestEgg remote not found")
        end
    end)
    return ok, err
end

-- Helper: fire _purchaseEgg remote with id, rarity, variety
local function firePurchaseEgg(id, rarity, variety)
    local ok, err = pcall(function()
        local args = {
            {
                __raw = true,
                data = {
                    id = id,
                    rarity = tostring(rarity or ""),
                    variety = tostring(variety or "")
                }
            }
        }
        local inst = game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Internals"):WaitForChild("Skeleton"):WaitForChild("Conduit"):WaitForChild("Instances")
        local pur = inst:FindFirstChild("_purchaseEgg")
        if pur and pur.FireServer then
            pur:FireServer(unpack(args))
        else
            error("_purchaseEgg remote not found")
        end
    end)
    return ok, err
end

-- Utility: wait for egg removal (confirmation of purchase) up to timeout seconds
local function waitForEggRemoval(timeout)
    local start = tick()
    while tick() - start < (timeout or purchaseTimeout) do
        local eggtag, _ = findEggTag()
        if not eggtag then
            return true
        end
        wait(0.15)
    end
    return false
end

-- Auto Buy+Spin toggle logic
_G.AutoBuySpinEggs = _G.AutoBuySpinEggs or false

local AutoBuySpinToggle = MainTab:CreateToggle({
    Name = "Auto Buy+Spin Eggs",
    CurrentValue = _G.AutoBuySpinEggs,
    Flag = "AutoBuySpinEggs",
    Callback = function(Value)
        _G.AutoBuySpinEggs = Value

        if Value then
            spawn(function()
                while _G.AutoBuySpinEggs do
                    pcall(function()
                        -- Refresh egg info
                        refreshCurrentEgg()

                        -- Read current stats
                        local parentName = currentParentName
                        local container = currentEggTag and (currentEggTag:FindFirstChild("Container") or currentEggTag) or nil
                        local price = container and readContainerField(container, "Price") or nil
                        local rarity = container and readContainerField(container, "Rarity") or nil
                        local variety = container and readContainerField(container, "Variety") or nil

                        -- Build id from parentName
                        local entityId = buildEntityIdFromParent(parentName)

                        -- If there is an egg present and it matches desired criteria, attempt purchase
                        -- Example rule: if price is numeric and <= threshold OR rarity matches desired; customize as needed
                        local numericPrice = tonumber(tostring(price)) or nil
                        local buyThreshold = 100 -- adjust as needed

                        -- If an egg exists and we haven't purchased it yet, attempt purchase
                        if currentEggTag then
                            -- Fire purchase remote directly using detected stats
                            if entityId and rarity and variety then
                                -- Attempt purchase
                                local ok, err = firePurchaseEgg(entityId, rarity, variety)
                                if ok then
                                    -- After firing purchase, wait for confirmation (egg removal)
                                    local confirmed = waitForEggRemoval(purchaseTimeout)
                                    if confirmed then
                                        lastPurchaseConfirmed = true
                                        print("[AutoBuySpin] Purchase confirmed for:", entityId, rarity, variety)
                                    else
                                        lastPurchaseConfirmed = false
                                        print("[AutoBuySpin] Purchase not confirmed within timeout for:", entityId, rarity, variety)
                                    end
                                else
                                    print("[AutoBuySpin] Purchase remote error:", err)
                                end
                            else
                                print("[AutoBuySpin] Missing entityId/rarity/variety; skipping purchase. Parent:", tostring(parentName), "Rarity:", tostring(rarity), "Variety:", tostring(variety))
                            end
                        else
                            -- No egg present. Only request a new egg if last purchase was confirmed.
                            if lastPurchaseConfirmed then
                                local ok, err = fireRequestEgg()
                                if ok then
                                    -- After requesting, set lastPurchaseConfirmed to false until we confirm a purchase
                                    lastPurchaseConfirmed = false
                                    -- Wait a short moment for the egg to spawn before next loop
                                    wait(0.5)
                                else
                                    print("[AutoBuySpin] RequestEgg error:", err)
                                end
                            else
                                -- Waiting for previous purchase confirmation; skip requesting new egg
                                print("[AutoBuySpin] Waiting for previous purchase confirmation before requesting new egg.")
                            end
                        end
                    end)
                    wait(1) -- adjust delay to avoid rate limits
                end
            end)
        end
    end,
})

-- Expose for external use if needed
_G.AutoBuySpinToggle = AutoBuySpinToggle
_G.GetCurrentEggInfo = function()
    return {
        EggTag = currentEggTag,
        ParentName = currentParentName,
        Price = currentEggTag and readContainerField(currentEggTag:FindFirstChild("Container") or currentEggTag, "Price") or nil,
        Rarity = currentEggTag and readContainerField(currentEggTag:FindFirstChild("Container") or currentEggTag, "Rarity") or nil,
        Variety = currentEggTag and readContainerField(currentEggTag:FindFirstChild("Container") or currentEggTag, "Variety") or nil,
    }
end

-- Initial refresh
pcall(refreshCurrentEgg)
