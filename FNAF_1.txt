-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a minimal, blank window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867"
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)

-- Egg Status UI (always enabled; toggle removed)
do
    local StatusTab = Window:CreateTab("Egg Status", 4483362458)
    local StatusSection = StatusTab:CreateSection("Spawned Egg Status")
    local StatusParagraph = StatusTab:CreateParagraph({Title = "Egg Status", Content = "Searching for spawned egg..."})

    -- Filter UI section
    local FilterSection = StatusTab:CreateSection("Filters")
    -- Rarity and Variety options
    local RARITY_OPTIONS = {"Normal", "Rare", "Epic", "Legendary", "Mythic", "Secret"}
    local VARIETY_OPTIONS = {"Normal", "Golden", "Diamond", "Glitch", "Galaxy", "????"}

    -- Default: all selected
    local selectedRarities = {}
    local selectedVarieties = {}
    for _, v in ipairs(RARITY_OPTIONS) do selectedRarities[string.lower(v)] = true end
    for _, v in ipairs(VARIETY_OPTIONS) do selectedVarieties[string.lower(v)] = true end

    -- Helper to convert a list to Rayfield's expected CurrentOption (table)
    local function copyList(tbl)
        local out = {}
        for i, v in ipairs(tbl) do out[i] = v end
        return out
    end

    -- Create dropdowns (multi-select). Rayfield dropdown APIs vary; this uses common Rayfield pattern.
    -- If your Rayfield version uses different keys for multi-select, adjust accordingly.
    StatusTab:CreateDropdown({
        Name = "Rarities",
        Options = RARITY_OPTIONS,
        CurrentOption = copyList(RARITY_OPTIONS),
        Flag = "RaritiesFilter",
        Multi = true,
        Callback = function(selection)
            -- selection is expected to be a table of selected strings
            -- reset and populate selectedRarities set
            selectedRarities = {}
            if type(selection) == "table" then
                for _, s in ipairs(selection) do
                    if type(s) == "string" then
                        selectedRarities[string.lower(s)] = true
                    end
                end
            elseif type(selection) == "string" then
                selectedRarities[string.lower(selection)] = true
            end
        end
    })

    StatusTab:CreateDropdown({
        Name = "Varieties",
        Options = VARIETY_OPTIONS,
        CurrentOption = copyList(VARIETY_OPTIONS),
        Flag = "VarietiesFilter",
        Multi = true,
        Callback = function(selection)
            selectedVarieties = {}
            if type(selection) == "table" then
                for _, s in ipairs(selection) do
                    if type(s) == "string" then
                        selectedVarieties[string.lower(s)] = true
                    end
                end
            elseif type(selection) == "string" then
                selectedVarieties[string.lower(selection)] = true
            end
        end
    })

    -- Always enabled; user cannot disable
    local enabled = true

    -- Robust reader: returns text/value from common GUI/value objects
    local function readTextOrValue(inst)
        if not inst then return nil end

        if inst:IsA("TextLabel") or inst:IsA("TextBox") or inst:IsA("TextButton") then
            if type(inst.Text) == "string" and inst.Text ~= "" then
                return inst.Text
            end
        end

        if inst:IsA("ValueBase") and inst.Value ~= nil then
            return tostring(inst.Value)
        end

        local ok, txt = pcall(function() return inst.Text end)
        if ok and type(txt) == "string" and txt ~= "" then return txt end
        local ok2, val = pcall(function() return inst.Value end)
        if ok2 and val ~= nil then return tostring(val) end

        for _, c in ipairs(inst:GetChildren()) do
            if c:IsA("TextLabel") or c:IsA("TextBox") or c:IsA("TextButton") then
                if type(c.Text) == "string" and c.Text ~= "" then
                    return c.Text
                end
            end
            if c:IsA("ValueBase") and c.Value ~= nil then
                return tostring(c.Value)
            end
        end

        for _, d in ipairs(inst:GetDescendants()) do
            if d:IsA("TextLabel") or d:IsA("TextBox") or d:IsA("TextButton") then
                if type(d.Text) == "string" and d.Text ~= "" then
                    return d.Text
                end
            end
            if d:IsA("ValueBase") and d.Value ~= nil then
                return tostring(d.Value)
            end
        end

        return nil
    end

    -- Search container for a field by name (case-insensitive) and return its readable value
    local function findFieldValue(container, nameCandidates)
        if not container then return nil end
        local lowerCandidates = {}
        for _, n in ipairs(nameCandidates) do lowerCandidates[#lowerCandidates+1] = string.lower(n) end

        for _, child in ipairs(container:GetChildren()) do
            local lname = string.lower(child.Name or "")
            for _, cand in ipairs(lowerCandidates) do
                if lname == cand or lname:find(cand) then
                    local v = readTextOrValue(child)
                    if v and v ~= "" then return v end
                end
            end
        end

        for _, desc in ipairs(container:GetDescendants()) do
            local lname = string.lower(desc.Name or "")
            for _, cand in ipairs(lowerCandidates) do
                if lname == cand or lname:find(cand) then
                    local v = readTextOrValue(desc)
                    if v and v ~= "" then return v end
                end
            end
        end

        for _, child in ipairs(container:GetChildren()) do
            local v = readTextOrValue(child)
            if v and v ~= "" then
                return v
            end
        end

        for _, desc in ipairs(container:GetDescendants()) do
            local v = readTextOrValue(desc)
            if v and v ~= "" then
                return v
            end
        end

        return nil
    end

    -- Scans workspace for all children that contain an Eggtag and returns a table of info
    local function getAllSpawnedEggsInfo()
        local results = {}
        for _, child in pairs(workspace:GetChildren()) do
            if child and child:FindFirstChild("Eggtag") then
                local tag = child:FindFirstChild("Eggtag")
                if tag and tag:FindFirstChild("Container") then
                    local container = tag.Container

                    local price = findFieldValue(container, {"Price", "price", "Cost", "cost", "Amount"}) or "N/A"
                    local rarity = findFieldValue(container, {"Rarity", "rarity", "Tier", "tier"}) or "N/A"
                    local variety = findFieldValue(container, {"Variety", "variety", "Type", "type"}) or "N/A"

                    local eggName = tostring(child.Name or "Unknown")
                    table.insert(results, {Name = eggName, Price = price, Rarity = rarity, Variety = variety, Container = container})
                end
            end
        end
        return results
    end

    -- Formats a list of egg infos into a string for the paragraph
    local function formatEggsForDisplay(eggs)
        if not eggs or #eggs == 0 then
            return "No egg detected."
        end
        local lines = {}
        for i, e in ipairs(eggs) do
            local line = string.format("%d) Name: %s | Price: %s | Rarity: %s | Variety: %s", i, tostring(e.Name), tostring(e.Price), tostring(e.Rarity), tostring(e.Variety))
            table.insert(lines, line)
        end
        return table.concat(lines, "\n")
    end

    -- Updater loop (always running)
    spawn(function()
        while true do
            if enabled then
                local ok, eggs = pcall(function()
                    return getAllSpawnedEggsInfo()
                end)

                if ok and eggs and #eggs > 0 then
                    local content = formatEggsForDisplay(eggs)
                    pcall(function()
                        StatusParagraph:Set({Title = "Egg Status", Content = content})
                    end)
                else
                    pcall(function()
                        StatusParagraph:Set({Title = "Egg Status", Content = "No egg detected."})
                    end)
                end
            end
            task.wait(0.5)
        end
    end)

    -- Auto Spawn + Buy Eggs toggle (uses existing getAllSpawnedEggsInfo)
    do
        local AutoSection = StatusTab:CreateSection("Auto Spawn+Buy")
        local autoEnabled = false
        local autoThread = nil

        -- Helper: sanitize name for id (replace spaces and non-alphanum with underscore)
        local function sanitizeNameForId(name)
            if not name then return "Unknown" end
            local s = tostring(name)
            s = s:gsub("%s+", "_")
            s = s:gsub("[^%w_]", "_")
            return s
        end

        -- Remote references (cached)
        local Rep = game:GetService("ReplicatedStorage")
        local function getRemote(name)
            local ok, rem = pcall(function()
                return Rep:WaitForChild("Modules"):WaitForChild("Internals"):WaitForChild("Skeleton"):WaitForChild("Conduit"):WaitForChild("Instances"):WaitForChild(name)
            end)
            if ok then return rem end
            return nil
        end
        local requestEggRemote = getRemote("_requestEgg")
        local purchaseEggRemote = getRemote("_purchaseEgg")

        -- Faster waitUntilNoEgg: shorter timeout and faster poll
        local function waitUntilNoEgg(timeout)
            local start = tick()
            local poll = 0.12
            while (tick() - start) < (timeout or 8) do
                local ok, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
                if ok and (not eggs or #eggs == 0) then
                    return true
                end
                task.wait(poll)
            end
            return false
        end

        -- Attempt to purchase the provided egg info (safe pcall)
        local function attemptPurchaseFromInfo(eggInfo)
            if not eggInfo or not purchaseEggRemote then return false end
            local namePart = sanitizeNameForId(eggInfo.Name or "Unknown")
            local rarityPart = tostring(eggInfo.Rarity or "Basic")
            local varietyPart = tostring(eggInfo.Variety or "Glitch")
            local idString = "entity_" .. namePart .. "_egg"
            local ok, err = pcall(function()
                local args = {
                    {
                        __raw = true,
                        data = {
                            id = idString,
                            rarity = rarityPart,
                            variety = varietyPart
                        }
                    }
                }
                purchaseEggRemote:FireServer(unpack(args))
            end)
            return ok
        end

        -- Helper: check if both rarity and variety are allowed (both must match)
        local function isEggAllowed(eggInfo)
            if not eggInfo then return false end
            local r = tostring(eggInfo.Rarity or ""):gsub("^%s*(.-)%s*$", "%1")
            local v = tostring(eggInfo.Variety or ""):gsub("^%s*(.-)%s*$", "%1")
            local rl = string.lower(r)
            local vl = string.lower(v)
            -- If selected sets are empty, treat as "none selected" -> disallow everything.
            -- This preserves explicit user control. If you prefer "none selected = allow all", change logic.
            if next(selectedRarities) == nil or next(selectedVarieties) == nil then
                return false
            end
            return selectedRarities[rl] == true and selectedVarieties[vl] == true
        end

        -- Core loop (sped up)
        local function autoSpawnBuyLoop()
            while autoEnabled do
                -- If an egg exists, evaluate it
                local ok, eggsNow = pcall(function() return getAllSpawnedEggsInfo() end)
                if ok and eggsNow and #eggsNow > 0 then
                    local current = eggsNow[1]
                    -- If allowed, attempt purchase and wait until cleared
                    if isEggAllowed(current) then
                        pcall(function()
                            attemptPurchaseFromInfo(current)
                        end)
                        waitUntilNoEgg(8)
                        task.wait(0.18)
                        continue
                    else
                        -- Not allowed: request a different egg immediately (user requested behavior)
                        if requestEggRemote then
                            pcall(function()
                                local args = {
                                    {
                                        __raw = true,
                                        data = {}
                                    }
                                }
                                requestEggRemote:FireServer(unpack(args))
                            end)
                        end
                        -- small pause to avoid spamming and allow server to process
                        task.wait(0.18)
                        -- continue loop to re-evaluate current egg or new egg
                        continue
                    end
                end

                -- If no egg detected, request a new spawn
                if requestEggRemote then
                    pcall(function()
                        local args = {
                            {
                                __raw = true,
                                data = {}
                            }
                        }
                        requestEggRemote:FireServer(unpack(args))
                    end)
                end

                -- Wait for detection (faster polling, shorter timeout)
                local detectedEgg = nil
                local startTime = tick()
                local timeout = 6 -- seconds to wait for an egg to appear (reduced)
                local pollInterval = 0.12
                while autoEnabled and (tick() - startTime) < timeout do
                    local ok2, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
                    if ok2 and eggs and #eggs > 0 then
                        detectedEgg = eggs[1]
                        break
                    end
                    task.wait(pollInterval)
                end

                -- If detected, check filters and act accordingly
                if detectedEgg then
                    if isEggAllowed(detectedEgg) then
                        pcall(function()
                            attemptPurchaseFromInfo(detectedEgg)
                        end)
                        waitUntilNoEgg(8)
                    else
                        -- Not allowed: request another spawn and continue
                        if requestEggRemote then
                            pcall(function()
                                local args = {
                                    {
                                        __raw = true,
                                        data = {}
                                    }
                                }
                                requestEggRemote:FireServer(unpack(args))
                            end)
                        end
                        task.wait(0.18)
                    end
                end

                -- Shorter cycle delay to speed up loop
                local cycleDelay = 0.3
                local waited = 0
                while autoEnabled and waited < cycleDelay do
                    task.wait(0.06)
                    waited = waited + 0.06
                end
            end
        end

        -- Create the Rayfield toggle
        StatusTab:CreateToggle({
            Name = "Auto Spawn+Buy Eggs",
            CurrentValue = false,
            Flag = "AutoSpawnBuyEggs",
            Callback = function(val)
                autoEnabled = val
                if autoEnabled then
                    if not autoThread or coroutine.status(autoThread) ~= "running" then
                        autoThread = spawn(function()
                            autoSpawnBuyLoop()
                        end)
                    end
                end
            end
        })
    end
end

