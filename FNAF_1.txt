-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a minimal, blank window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    -- Parent to the same UI context Rayfield uses so it appears alongside the Rayfield UI
    -- If Rayfield:GetParent() or its parent is nil, fall back to CoreGui
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867" -- replace with your decal id if desired
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    -- Toggle Rayfield visibility on click
    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- === Egg Info UI (Rayfield) ===
local EggTab = Window:CreateTab("Egg Info", 4483362458)

-- Paragraph to show egg info
local EggParagraph = EggTab:CreateParagraph({
    Title = "Spawned Egg",
    Content = "Price: -\nVariety: -\nRarity: -\nMutation: -"
})

-- Optional debug toggle in UI (helps troubleshooting)
local DebugToggle = EggTab:CreateToggle({
    Name = "Debug prints",
    CurrentValue = false,
    Flag = "EggInfoDebug",
    Callback = function(val) end,
})

-- Helper: safe print when debug enabled
local function dbg(...)
    if DebugToggle and DebugToggle.CurrentValue then
        local t = {}
        for i = 1, select("#", ...) do
            t[#t+1] = tostring(select(i, ...))
        end
        print("[EggInfo DEBUG] " .. table.concat(t, " "))
    end
end

-- Utility: format and update the paragraph
local function updateParagraph(price, variety, rarity, mutation)
    price = price or "Unknown"
    variety = variety or "Unknown"
    rarity = rarity or "Unknown"
    mutation = mutation or "Unknown"
    local content = string.format("Price: %s\nVariety: %s\nRarity: %s\nMutation: %s", tostring(price), tostring(variety), tostring(rarity), tostring(mutation))
    pcall(function() EggParagraph:Set({Title = "Spawned Egg", Content = content}) end)
end

-- Robust extractor: checks attributes, child values, and common naming
local function extractEggInfoFromModel(model)
    if not model or not model:IsA("Model") then return nil end

    -- quick heuristics: model name contains "egg" or model has children that look like egg metadata
    local nameLower = tostring(model.Name):lower()
    local looksLikeEgg = nameLower:find("egg") ~= nil

    -- collect attributes (case-insensitive)
    local function getAttr(m, names)
        for _, n in ipairs(names) do
            local v = m:GetAttribute(n)
            if v ~= nil then return v end
        end
        return nil
    end

    local price = getAttr(model, {"price", "base_price", "BasePrice", "Price"})
    local rarity = getAttr(model, {"rarity", "Rarity"})
    local mutation = getAttr(model, {"mutation", "mutated", "is_mutated", "Mutation"})
    local variety = getAttr(model, {"variety", "variant", "display_name", "displayName", "name"})

    -- search children for common value objects (StringValue, IntValue, NumberValue, BoolValue)
    local function findChildValue(m, names)
        for _, n in ipairs(names) do
            local c = m:FindFirstChild(n)
            if c then
                if c:IsA("StringValue") or c:IsA("IntValue") or c:IsA("NumberValue") or c:IsA("BoolValue") then
                    return c.Value
                end
            end
        end
        return nil
    end

    price = price or findChildValue(model, {"Price", "price", "BasePrice", "base_price"})
    rarity = rarity or findChildValue(model, {"Rarity", "rarity"})
    mutation = mutation or findChildValue(model, {"Mutation", "mutation", "Mutated", "mutated"})
    variety = variety or findChildValue(model, {"Variety", "variety", "Variant", "variant", "DisplayName", "display_name"})

    -- If still missing, check descendants for any child whose name suggests metadata
    if not (price and rarity and variety) then
        for _, desc in ipairs(model:GetDescendants()) do
            if desc:IsA("StringValue") or desc:IsA("IntValue") or desc:IsA("NumberValue") or desc:IsA("BoolValue") then
                local dn = desc.Name:lower()
                if not price and (dn:find("price") or dn:find("base")) then price = desc.Value end
                if not rarity and dn:find("rar") then rarity = desc.Value end
                if not mutation and (dn:find("mutat") or dn:find("mut")) then mutation = desc.Value end
                if not variety and (dn:find("var") or dn:find("display") or dn:find("name")) then variety = desc.Value end
            end
        end
    end

    -- If nothing found but model name contains egg, use model.Name as variety
    if not variety and looksLikeEgg then
        variety = model.Name
    end

    -- Normalize mutation boolean to readable string
    if type(mutation) == "boolean" then
        mutation = mutation and "Yes" or "No"
    end

    -- If we have at least one meaningful field, consider this an egg
    if price or rarity or variety or mutation or looksLikeEgg then
        return {
            price = price,
            variety = variety,
            rarity = rarity,
            mutation = mutation,
            model = model
        }
    end

    return nil
end

-- Stronger detection: check a candidate instance (Model or descendant) and return info if it's an egg
local function inspectCandidate(inst)
    if not inst then return nil end

    -- If inst is a Model, try it directly
    if inst:IsA("Model") then
        local info = extractEggInfoFromModel(inst)
        if info then
            dbg("Found egg model:", inst:GetFullName())
            return info
        end
    end

    -- If inst is a descendant (e.g., a StringValue or part), check its parent model chain
    local parent = inst.Parent
    while parent and parent ~= workspace do
        if parent:IsA("Model") then
            local info = extractEggInfoFromModel(parent)
            if info then
                dbg("Found egg via descendant:", inst:GetFullName(), "->", parent:GetFullName())
                return info
            end
        end
        parent = parent.Parent
    end

    return nil
end

-- Keep track of the last displayed egg to avoid redundant updates
local lastDisplayed = {
    model = nil,
    price = nil,
    variety = nil,
    rarity = nil,
    mutation = nil
}

-- Update UI if info changed
local function maybeUpdateUI(info)
    if not info then
        updateParagraph(nil, nil, nil, nil)
        lastDisplayed = {model = nil}
        return
    end

    local changed = false
    if info.model ~= lastDisplayed.model then changed = true end
    if tostring(info.price) ~= tostring(lastDisplayed.price) then changed = true end
    if tostring(info.variety) ~= tostring(lastDisplayed.variety) then changed = true end
    if tostring(info.rarity) ~= tostring(lastDisplayed.rarity) then changed = true end
    if tostring(info.mutation) ~= tostring(lastDisplayed.mutation) then changed = true end

    if changed then
        dbg("Updating UI:", info.price, info.variety, info.rarity, info.mutation)
        updateParagraph(info.price, info.variety, info.rarity, info.mutation)
        lastDisplayed.model = info.model
        lastDisplayed.price = info.price
        lastDisplayed.variety = info.variety
        lastDisplayed.rarity = info.rarity
        lastDisplayed.mutation = info.mutation
    end
end

-- Search workspace for likely eggs (initial scan and fallback)
local function scanWorkspaceForEgg()
    -- Common roots where eggs might appear
    local roots = {
        workspace:FindFirstChild("Entities"),
        workspace:FindFirstChild("SpawnedEggs"),
        workspace:FindFirstChild("Eggs"),
        workspace:FindFirstChild("Plots"),
        workspace
    }

    for _, root in ipairs(roots) do
        if root and root:IsA("Instance") then
            for _, child in ipairs(root:GetDescendants()) do
                local info = inspectCandidate(child)
                if info then
                    return info
                end
            end
        end
    end
    return nil
end

-- Main refresh routine: tries to find the most relevant egg and update UI
local function refreshEggInfo()
    local ok, info = pcall(scanWorkspaceForEgg)
    if ok and info then
        maybeUpdateUI(info)
        return
    end
    -- nothing found
    maybeUpdateUI(nil)
end

-- Event-driven updates: when new descendants are added, inspect them
workspace.DescendantAdded:Connect(function(desc)
    -- quick filter to reduce noise
    local nameLower = tostring(desc.Name):lower()
    if desc:IsA("Model") or nameLower:find("egg") or nameLower:find("price") or nameLower:find("rarity") or nameLower:find("mutation") or nameLower:find("uuid") or nameLower:find("entity") then
        wait(0.05) -- small delay to allow attributes/children to be set
        local ok, info = pcall(inspectCandidate, desc)
        if ok and info then
            maybeUpdateUI(info)
        end
    end
end)

-- If a model's attributes change, re-inspect that model
local function connectAttributeWatcher(model)
    if not model or not model:IsA("Model") then return end
    -- Avoid connecting multiple times
    if model:GetAttribute("__eggInfoWatcher") then return end
    model:SetAttribute("__eggInfoWatcher", true)

    -- AttributeChanged is available on Instances
    if model.AttributeChangedSignal then
        model.AttributeChangedSignal:Connect(function(attr)
            if attr and (attr:lower():find("price") or attr:lower():find("rar") or attr:lower():find("mutat") or attr:lower():find("var")) then
                wait(0.02)
                local ok, info = pcall(extractEggInfoFromModel, model)
                if ok and info then maybeUpdateUI(info) end
            end
        end)
    end

    -- Also watch children added to the model (value objects)
    model.ChildAdded:Connect(function(child)
        if child:IsA("StringValue") or child:IsA("IntValue") or child:IsA("NumberValue") or child:IsA("BoolValue") then
            wait(0.02)
            local ok, info = pcall(extractEggInfoFromModel, model)
            if ok and info then maybeUpdateUI(info) end
        end
    end)
end

-- Connect watchers for existing models in workspace (so attribute changes are caught)
local function connectExistingModels()
    for _, m in ipairs(workspace:GetDescendants()) do
        if m:IsA("Model") then
            connectAttributeWatcher(m)
        end
    end
end

-- Also connect to new models to watch their attributes
workspace.DescendantAdded:Connect(function(desc)
    if desc:IsA("Model") then
        connectAttributeWatcher(desc)
    else
        -- if a child of a model is added, ensure its parent model is watched
        local parent = desc.Parent
        while parent and parent ~= workspace do
            if parent:IsA("Model") then
                connectAttributeWatcher(parent)
                break
            end
            parent = parent.Parent
        end
    end
end)

-- Initial setup
connectExistingModels()
refreshEggInfo()

-- Periodic polling fallback (in case events miss something)
spawn(function()
    while true do
        pcall(refreshEggInfo)
        wait(1.5)
    end
end)

-- === End Egg Info UI ===

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)

-- Debug note for user: if UI still doesn't show values, enable "Debug prints" toggle and check Output for [EggInfo DEBUG] messages.
