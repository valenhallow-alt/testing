-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a minimal, blank window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    -- Parent to the same UI context Rayfield uses so it appears alongside the Rayfield UI
    -- If Rayfield:GetParent() or its parent is nil, fall back to CoreGui
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867" -- replace with your decal id if desired
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    -- Toggle Rayfield visibility on click
    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- === Egg Info UI (Rayfield) ===
local EggTab = Window:CreateTab("Egg Info", 4483362458)

-- Use a paragraph so we can update multiple lines easily
local EggParagraph = EggTab:CreateParagraph({
    Title = "Spawned Egg",
    Content = "Price: -\nVariety: -\nRarity: -\nMutation: -"
})

-- Helper: try to build a lookup table from ReplicatedStorage metadata if present
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local EggMetaLookup = nil
do
    -- Many games store egg metadata in ReplicatedStorage.Assets or a ModuleScript.
    -- Try a few common locations safely.
    pcall(function()
        local assets = ReplicatedStorage:FindFirstChild("Assets")
        if assets then
            local eggsFolder = assets:FindFirstChild("Eggs")
            if eggsFolder and eggsFolder:IsA("Folder") then
                EggMetaLookup = {}
                for _, child in ipairs(eggsFolder:GetChildren()) do
                    -- child.Name may be the entity id or model name; store a minimal record
                    -- Attempt to read common metadata values if present as attributes or children
                    local meta = {}
                    meta.display_name = child:GetAttribute("display_name") or child.Name
                    meta.base_price = child:GetAttribute("base_price") or child:GetAttribute("price")
                    meta.rarity = child:GetAttribute("rarity")
                    -- If the child is a ModuleScript, try requiring it for richer data
                    if child:IsA("ModuleScript") then
                        local ok, data = pcall(require, child)
                        if ok and type(data) == "table" then
                            for k, v in pairs(data) do meta[k] = v end
                        end
                    end
                    EggMetaLookup[child.Name] = meta
                end
            end
        end
    end)

    -- Try to require a module that contains egg definitions (some games use a ModuleScript)
    pcall(function()
        if not EggMetaLookup then
            local possible = ReplicatedStorage:FindFirstChild("EggDefinitions") or ReplicatedStorage:FindFirstChild("EggsData") or (ReplicatedStorage:FindFirstChild("Configuration") and ReplicatedStorage.Configuration:FindFirstChild("Eggs"))
            if possible and possible:IsA("ModuleScript") then
                local ok, data = pcall(require, possible)
                if ok and type(data) == "table" then
                    EggMetaLookup = data
                end
            end
        end
    end)
end

-- Utility: format and update the paragraph
local function updateParagraph(price, variety, rarity, mutation)
    price = price or "Unknown"
    variety = variety or "Unknown"
    rarity = rarity or "Unknown"
    mutation = mutation or "Unknown"
    local content = string.format("Price: %s\nVariety: %s\nRarity: %s\nMutation: %s", tostring(price), tostring(variety), tostring(rarity), tostring(mutation))
    pcall(function() EggParagraph:Set({Title = "Spawned Egg", Content = content}) end)
end

-- Try to extract metadata from a model instance
local function readEggFromInstance(inst)
    if not inst or not inst:IsA("Model") then return nil end

    -- Common attribute names used by many games
    local entity_id = inst:GetAttribute("entity_id") or inst:GetAttribute("EntityId") or inst:GetAttribute("id") or inst.Name
    local price = inst:GetAttribute("price") or inst:GetAttribute("base_price")
    local rarity = inst:GetAttribute("rarity")
    local mutation = inst:GetAttribute("mutation") or inst:GetAttribute("mutated")
    local variety = inst:GetAttribute("variety") or inst:GetAttribute("variant") or inst.Name

    -- If some fields are missing but we have an entity_id, try lookup table
    if (not price or not rarity or not variety) and entity_id and EggMetaLookup and EggMetaLookup[entity_id] then
        local meta = EggMetaLookup[entity_id]
        price = price or meta.base_price or meta.price
        rarity = rarity or meta.rarity
        variety = variety or meta.display_name or meta.entity_id or meta.name
    end

    -- Final fallback: try to find child values (StringValue/IntValue/NumberValue/BoolValue) inside the model
    if not price then
        local v = inst:FindFirstChild("Price") or inst:FindFirstChild("BasePrice") or inst:FindFirstChild("price")
        if v and (v:IsA("IntValue") or v:IsA("NumberValue") or v:IsA("StringValue")) then
            price = v.Value
        end
    end
    if not rarity then
        local v = inst:FindFirstChild("Rarity") or inst:FindFirstChild("rarity")
        if v and v:IsA("StringValue") then rarity = v.Value end
    end
    if not mutation then
        local v = inst:FindFirstChild("Mutation") or inst:FindFirstChild("Mutated") or inst:FindFirstChild("mutation")
        if v and (v:IsA("BoolValue") or v:IsA("StringValue") or v:IsA("IntValue") or v:IsA("NumberValue")) then mutation = v.Value end
    end

    -- Normalize mutation to readable string
    if type(mutation) == "boolean" then
        mutation = mutation and "Yes" or "No"
    end

    return {
        price = price,
        variety = variety,
        rarity = rarity,
        mutation = mutation,
        entity_id = entity_id
    }
end

-- Heuristic: find the "currently spawned egg" in workspace
local function findSpawnedEgg()
    -- Common places to look: workspace.Entities, workspace.SpawnedEggs, workspace.Eggs, workspace.Plots
    local searchRoots = {
        workspace:FindFirstChild("Entities"),
        workspace:FindFirstChild("SpawnedEggs"),
        workspace:FindFirstChild("Eggs"),
        workspace:FindFirstChild("Plots"),
        workspace
    }

    for _, root in ipairs(searchRoots) do
        if root and root:IsA("Instance") then
            for _, inst in ipairs(root:GetDescendants()) do
                if inst:IsA("Model") then
                    -- Heuristics: model has attribute entity_id, or name contains "Egg", or has a child named "UUID" or "Entity"
                    if inst:GetAttribute("entity_id") or inst:GetAttribute("EntityId") or inst.Name:lower():find("egg") or inst:FindFirstChild("UUID") or inst:FindFirstChild("EntityId") then
                        return inst
                    end
                end
            end
        end
    end
    return nil
end

-- Watch for changes: update when a new egg appears or attributes change
local currentEgg = nil
local function refresh()
    local eggInst = findSpawnedEgg()
    if eggInst ~= currentEgg then
        currentEgg = eggInst
    end
    if currentEgg then
        local info = readEggFromInstance(currentEgg)
        if info then
            updateParagraph(info.price, info.variety, info.rarity, info.mutation)
            return
        end
    end
    updateParagraph(nil, nil, nil, nil)
end

-- Initial refresh
refresh()

-- Connect to workspace descendant added/removed to update quickly
workspace.DescendantAdded:Connect(function(desc)
    -- small debounce: only act on Models or children that hint at eggs
    if desc:IsA("Model") or desc.Name:match("Egg") or desc.Name:match("UUID") or desc.Name:match("EntityId") then
        wait(0.1)
        pcall(refresh)
    end
end)
workspace.DescendantRemoving:Connect(function(desc)
    if desc == currentEgg then
        wait(0.1)
        pcall(refresh)
    end
end)

-- Also poll periodically as a fallback (in case attributes are set after spawn)
spawn(function()
    while true do
        pcall(refresh)
        wait(2)
    end
end)
-- === End Egg Info UI ===

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)
