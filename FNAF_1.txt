-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library
local success, Rayfield = pcall(function()
    return loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
end)
if not success or not Rayfield then
    warn("Failed to load Rayfield. Ensure HTTP requests are allowed and the URL is reachable.")
    return
end
_G.RayfieldInstance = Rayfield

-- Safe window creation helper (waits for Rayfield to be ready)
local function safeCreateWindow(createArgs, timeout)
    timeout = timeout or 6
    local start = tick()
    while tick() - start < timeout do
        if Rayfield and type(Rayfield.CreateWindow) == "function" then
            local ok, win = pcall(function() return Rayfield:CreateWindow(createArgs) end)
            if ok and win then
                return win
            end
        end
        task.wait(0.12)
    end
    return nil
end

local Window = safeCreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
}, 8)

if not Window then
    warn("Rayfield failed to initialize or CreateWindow timed out. UI will not be created.")
    return
end

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867"
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)

-- Egg Status UI and Auto Spawn/Buy logic
do
    local Players = game:GetService("Players")
    local Rep = game:GetService("ReplicatedStorage")

    local StatusTab = Window:CreateTab("Egg Status", 4483362458)
    local StatusSection = StatusTab:CreateSection("Spawned Egg Status")
    local StatusParagraph = StatusTab:CreateParagraph({Title = "Egg Status", Content = "Searching for spawned egg..."})

    -- Filter UI section
    local FilterSection = StatusTab:CreateSection("Filters")
    local RARITY_OPTIONS = {"Basic", "Rare", "Epic", "Legendary", "Mythic", "Secret"}
    local VARIETY_OPTIONS = {"Normal", "Golden", "Diamond", "Glitch", "Galaxy", "????"}

    -- Selected sets (lowercase keys)
    local selectedRarities = {}
    local selectedVarieties = {}
    for _, v in ipairs(RARITY_OPTIONS) do selectedRarities[string.lower(v)] = true end
    for _, v in ipairs(VARIETY_OPTIONS) do selectedVarieties[string.lower(v)] = true end

    local function copyList(tbl)
        local out = {}
        for i, v in ipairs(tbl) do out[i] = v end
        return out
    end

    -- Speed control defaults (these will be driven by the slider)
    local spawnInterval = 1.0          -- seconds between spawn requests (default 1s -> ~60/min)
    local requestCooldown = 0.22       -- minimum seconds between requestEgg calls
    local attemptDelay = 1.0           -- delay between replacement attempts
    local pollInterval = 0.18          -- polling interval for status checks
    local purchaseRetryDelay = 0.6     -- delay between purchase retries

    -- Apply slider value to all timing variables (keeps relationships sensible)
    local function applySpeed(s)
        spawnInterval = tonumber(s) or 1.0
        -- keep a minimum cooldown so we don't spam too fast
        requestCooldown = math.max(0.12, spawnInterval * 0.22)
        attemptDelay = math.max(0.12, spawnInterval)
        pollInterval = math.max(0.08, spawnInterval * 0.18)
        purchaseRetryDelay = math.max(0.4, spawnInterval * 0.6)
    end

    -- Initialize speeds
    applySpeed(spawnInterval)

    -- Wait helper for StatusTab API readiness
    local function waitForStatusTab(tab, timeout)
        timeout = timeout or 6
        local start = tick()
        while tick() - start < timeout do
            if tab and type(tab.CreateDropdown) == "function" then
                return true
            end
            task.wait(0.12)
        end
        return false
    end

    -- Create dropdowns and slider only when API is ready
    if not waitForStatusTab(StatusTab, 6) then
        warn("StatusTab or CreateDropdown not available; dropdowns not created.")
    else
        -- Rarities dropdown (multi-select)
        local RaritiesDropdown = StatusTab:CreateDropdown({
            Name = "Rarities",
            Options = RARITY_OPTIONS,
            CurrentOption = copyList(RARITY_OPTIONS),
            MultipleOptions = true,
            Flag = "RaritiesFilter",
            Callback = function(selection)
                selectedRarities = {}
                if type(selection) == "table" then
                    for _, s in ipairs(selection) do
                        if type(s) == "string" then
                            selectedRarities[string.lower(s)] = true
                        end
                    end
                elseif type(selection) == "string" then
                    selectedRarities[string.lower(selection)] = true
                end
            end,
        })

        pcall(function()
            local init = (RaritiesDropdown and RaritiesDropdown.CurrentOption) or copyList(RARITY_OPTIONS)
            if type(init) == "table" then
                selectedRarities = {}
                for _, s in ipairs(init) do
                    if type(s) == "string" then selectedRarities[string.lower(s)] = true end
                end
            end
        end)

        -- Varieties dropdown (multi-select)
        local VarietiesDropdown = StatusTab:CreateDropdown({
            Name = "Varieties",
            Options = VARIETY_OPTIONS,
            CurrentOption = copyList(VARIETY_OPTIONS),
            MultipleOptions = true,
            Flag = "VarietiesFilter",
            Callback = function(selection)
                selectedVarieties = {}
                if type(selection) == "table" then
                    for _, s in ipairs(selection) do
                        if type(s) == "string" then
                            selectedVarieties[string.lower(s)] = true
                        end
                    end
                elseif type(selection) == "string" then
                    selectedVarieties[string.lower(selection)] = true
                end
            end,
        })

        pcall(function()
            local init = (VarietiesDropdown and VarietiesDropdown.CurrentOption) or copyList(VARIETY_OPTIONS)
            if type(init) == "table" then
                selectedVarieties = {}
                for _, s in ipairs(init) do
                    if type(s) == "string" then selectedVarieties[string.lower(s)] = true end
                end
            end
        end)

        -- Slider: controls the global speed (0.3s - 1s)
        local SpeedSlider = StatusTab:CreateSlider({
            Name = "Spawn Interval (seconds)",
            Range = {0.3, 1.0},
            Increment = 0.05,
            Suffix = "s",
            CurrentValue = spawnInterval,
            Flag = "SpawnInterval",
            Callback = function(value)
                applySpeed(value)
            end,
        })
    end

    -- Utility: read text/value from GUI/value objects
    local function readTextOrValue(inst)
        if not inst then return nil end
        if inst:IsA("TextLabel") or inst:IsA("TextBox") or inst:IsA("TextButton") then
            if type(inst.Text) == "string" and inst.Text ~= "" then return inst.Text end
        end
        if inst:IsA("ValueBase") and inst.Value ~= nil then return tostring(inst.Value) end
        local ok, txt = pcall(function() return inst.Text end)
        if ok and type(txt) == "string" and txt ~= "" then return txt end
        local ok2, val = pcall(function() return inst.Value end)
        if ok2 and val ~= nil then return tostring(val) end
        for _, c in ipairs(inst:GetChildren()) do
            if c:IsA("TextLabel") or c:IsA("TextBox") or c:IsA("TextButton") then
                if type(c.Text) == "string" and c.Text ~= "" then return c.Text end
            end
            if c:IsA("ValueBase") and c.Value ~= nil then return tostring(c.Value) end
        end
        for _, d in ipairs(inst:GetDescendants()) do
            if d:IsA("TextLabel") or d:IsA("TextBox") or d:IsA("TextButton") then
                if type(d.Text) == "string" and d.Text ~= "" then return d.Text end
            end
            if d:IsA("ValueBase") and d.Value ~= nil then return tostring(d.Value) end
        end
        return nil
    end

    -- Parse price string into a number (strip non-digits)
    local function parsePriceToNumber(priceStr)
        if not priceStr then return nil end
        local cleaned = tostring(priceStr):gsub("[^%d%-]", "")
        local n = tonumber(cleaned)
        return n or nil
    end

    -- Get player's current cash (IntValue under leaderstats.Cash)
    local function getPlayerCash()
        local pl = Players.LocalPlayer
        if not pl then return 0 end
        local leaderstats = pl:FindFirstChild("leaderstats")
        if not leaderstats then return 0 end
        local cash = leaderstats:FindFirstChild("Cash")
        if not cash then return 0 end
        return tonumber(cash.Value) or 0
    end

    -- Search container for a field by name (case-insensitive) and return its readable value
    local function findFieldValue(container, nameCandidates)
        if not container then return nil end
        local lowerCandidates = {}
        for _, n in ipairs(nameCandidates) do lowerCandidates[#lowerCandidates+1] = string.lower(n) end
        for _, child in ipairs(container:GetChildren()) do
            local lname = string.lower(child.Name or "")
            for _, cand in ipairs(lowerCandidates) do
                if lname == cand or lname:find(cand) then
                    local v = readTextOrValue(child)
                    if v and v ~= "" then return v end
                end
            end
        end
        for _, desc in ipairs(container:GetDescendants()) do
            local lname = string.lower(desc.Name or "")
            for _, cand in ipairs(lowerCandidates) do
                if lname == cand or lname:find(cand) then
                    local v = readTextOrValue(desc)
                    if v and v ~= "" then return v end
                end
            end
        end
        for _, child in ipairs(container:GetChildren()) do
            local v = readTextOrValue(child)
            if v and v ~= "" then return v end
        end
        for _, desc in ipairs(container:GetDescendants()) do
            local v = readTextOrValue(desc)
            if v and v ~= "" then return v end
        end
        return nil
    end

    -- Scans workspace for all children that contain an Eggtag and returns a table of info
    local function getAllSpawnedEggsInfo()
        local results = {}
        for _, child in pairs(workspace:GetChildren()) do
            if child and child:FindFirstChild("Eggtag") then
                local tag = child:FindFirstChild("Eggtag")
                if tag and tag:FindFirstChild("Container") then
                    local container = tag.Container
                    local priceStr = findFieldValue(container, {"Price", "price", "Cost", "cost", "Amount"}) or "N/A"
                    local priceNum = parsePriceToNumber(priceStr) or 0
                    local rarity = findFieldValue(container, {"Rarity", "rarity", "Tier", "tier"}) or "N/A"
                    local variety = findFieldValue(container, {"Variety", "variety", "Type", "type", "Mutation", "mutation"}) or "N/A"
                    local eggName = tostring(child.Name or "Unknown")
                    table.insert(results, {
                        Name = eggName,
                        Price = priceStr,
                        PriceNum = priceNum,
                        Rarity = rarity,
                        Variety = variety,
                        Container = container
                    })
                end
            end
        end
        return results
    end

    -- Formats a list of egg infos into a string for the paragraph
    local function formatEggsForDisplay(eggs)
        if not eggs or #eggs == 0 then return "No egg detected." end
        local lines = {}
        for i, e in ipairs(eggs) do
            local line = string.format("%d) Name: %s | Price: %s | Rarity: %s | Variety: %s", i, tostring(e.Name), tostring(e.Price), tostring(e.Rarity), tostring(e.Variety))
            table.insert(lines, line)
        end
        return table.concat(lines, "\n")
    end

    -- Updater loop (always running) to refresh the status paragraph
    spawn(function()
        while true do
            local ok, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
            if ok and eggs and #eggs > 0 then
                local content = formatEggsForDisplay(eggs)
                pcall(function() StatusParagraph:Set({Title = "Egg Status", Content = content}) end)
            else
                pcall(function() StatusParagraph:Set({Title = "Egg Status", Content = "No egg detected."}) end)
            end
            task.wait(math.max(0.5, pollInterval))
        end
    end)

    -- Remote references (cached)
    local function getRemote(name)
        local ok, rem = pcall(function()
            return Rep:WaitForChild("Modules"):WaitForChild("Internals"):WaitForChild("Skeleton"):WaitForChild("Conduit"):WaitForChild("Instances"):WaitForChild(name)
        end)
        if ok then return rem end
        return nil
    end
    local requestEggRemote = getRemote("_requestEgg")
    local purchaseEggRemote = getRemote("_purchaseEgg")

    -- Wait until no egg present (poll)
    local function waitUntilNoEgg(timeout)
        local start = tick()
        while (tick() - start) < (timeout or 8) do
            local ok, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
            if ok and (not eggs or #eggs == 0) then return true end
            task.wait(pollInterval)
        end
        return false
    end

    -- Attempt to purchase the provided egg info (safe pcall).
    -- Returns true only if the egg disappears (indicating a successful purchase).
    local function attemptPurchaseFromInfo(eggInfo, waitForDisappear)
        if not eggInfo or not purchaseEggRemote then return false end
        local namePart = tostring(eggInfo.Name or "Unknown"):gsub("%s+", "_"):gsub("[^%w_]", "_")
        local rarityPart = tostring(eggInfo.Rarity or "Basic")
        local varietyPart = tostring(eggInfo.Variety or "Glitch")
        local idString = "entity_" .. namePart .. "_egg"

        local okFire = pcall(function()
            local args = {
                {
                    __raw = true,
                    data = {
                        id = idString,
                        rarity = rarityPart,
                        variety = varietyPart
                    }
                }
            }
            purchaseEggRemote:FireServer(unpack(args))
        end)
        if not okFire then return false end

        if not waitForDisappear then return true end

        local start = tick()
        while (tick() - start) < 5 do
            local ok, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
            if ok then
                if not eggs or #eggs == 0 then return true end
                if tostring(eggs[1].Name or "") ~= tostring(eggInfo.Name or "") then return true end
            end
            task.wait(pollInterval)
        end
        return false
    end

    -- Helper: check if both rarity and variety are allowed (both must match)
    local function isEggAllowed(eggInfo)
        if not eggInfo then return false end
        local r = tostring(eggInfo.Rarity or ""):gsub("^%s*(.-)%s*$", "%1")
        local v = tostring(eggInfo.Variety or ""):gsub("^%s*(.-)%s*$", "%1")
        local rl = string.lower(r)
        local vl = string.lower(v)
        if next(selectedRarities) == nil or next(selectedVarieties) == nil then return false end
        return selectedRarities[rl] == true and selectedVarieties[vl] == true
    end

    -- State & timing controls
    local autoEnabled = false
    local autoThread = nil
    local replacing = false
    local lastRequestTime = 0

    -- Aggressive replace but controlled by spawnInterval and attemptDelay
    local function aggressiveReplaceUntilAllowed(currentEgg)
        replacing = true
        local startName = tostring(currentEgg.Name or "")
        local SAFETY_MAX_ATTEMPTS = math.max(6, math.floor(30 * (1.0 / spawnInterval))) -- scale attempts with speed
        for attempt = 1, SAFETY_MAX_ATTEMPTS do
            if not autoEnabled then break end

            if tick() - lastRequestTime >= requestCooldown then
                if requestEggRemote then
                    pcall(function()
                        local args = {
                            {
                                __raw = true,
                                data = {}
                            }
                        }
                        requestEggRemote:FireServer(unpack(args))
                    end)
                end
                lastRequestTime = tick()
            end

            task.wait(attemptDelay)

            local ok, eggsAfter = pcall(function() return getAllSpawnedEggsInfo() end)
            if ok and eggsAfter and #eggsAfter > 0 then
                local newEgg = eggsAfter[1]
                local newName = tostring(newEgg.Name or "")
                if newName ~= startName then
                    if isEggAllowed(newEgg) then
                        replacing = false
                        return newEgg
                    else
                        startName = newName
                    end
                end
            else
                task.wait(math.min(0.25, attemptDelay))
            end
        end
        replacing = false
        return nil
    end

    -- Core loop: spawn at roughly 1/spawnInterval requests per second (user-controlled)
    local function autoSpawnBuyLoop()
        while autoEnabled do
            local ok, eggsNow = pcall(function() return getAllSpawnedEggsInfo() end)
            if not ok then eggsNow = {} end
            local current = (eggsNow and #eggsNow > 0) and eggsNow[1] or nil

            if current and isEggAllowed(current) then
                -- Allowed egg present: check affordability
                local cash = getPlayerCash()
                local cost = tonumber(current.PriceNum) or 0

                if cost > 0 and cash >= cost then
                    -- Attempt purchase with retries
                    local purchased = false
                    for attempt = 1, 3 do
                        if not autoEnabled then break end
                        purchased = attemptPurchaseFromInfo(current, true)
                        if purchased then break end
                        task.wait(purchaseRetryDelay)
                    end

                    if purchased then
                        waitUntilNoEgg(10)
                        task.wait(0.25)
                    else
                        waitUntilNoEgg(12)
                        task.wait(0.25)
                    end
                else
                    -- Can't afford: wait until we have enough or egg disappears
                    local affordTimeout = 180
                    local start = tick()
                    while autoEnabled and (tick() - start) < affordTimeout do
                        local newCash = getPlayerCash()
                        local ok2, eggsCheck = pcall(function() return getAllSpawnedEggsInfo() end)
                        if ok2 and (not eggsCheck or #eggsCheck == 0) then break end
                        if newCash >= cost then
                            local purchased = attemptPurchaseFromInfo(current, true)
                            if purchased then waitUntilNoEgg(10) end
                            break
                        end
                        task.wait(math.max(0.25, pollInterval))
                    end
                    task.wait(0.25)
                end
            else
                -- No allowed egg present: request a new spawn (respect spawnInterval and cooldown)
                if not replacing and tick() - lastRequestTime >= requestCooldown then
                    if requestEggRemote then
                        pcall(function()
                            local args = {
                                {
                                    __raw = true,
                                    data = {}
                                }
                            }
                            requestEggRemote:FireServer(unpack(args))
                        end)
                        lastRequestTime = tick()
                    end
                end

                -- Wait spawnInterval seconds (user-controlled) before next request
                local waited = 0
                while autoEnabled and waited < spawnInterval do
                    task.wait(math.min(0.12, spawnInterval))
                    waited = waited + math.min(0.12, spawnInterval)
                end

                -- After waiting, re-scan and if a not-allowed egg is present, try controlled replacement
                local ok2, eggsAfter = pcall(function() return getAllSpawnedEggsInfo() end)
                if ok2 and eggsAfter and #eggsAfter > 0 then
                    local newEgg = eggsAfter[1]
                    if not isEggAllowed(newEgg) and not replacing then
                        -- try to replace aggressively but controlled
                        local allowedEgg = aggressiveReplaceUntilAllowed(newEgg)
                        if allowedEgg then
                            local cash = getPlayerCash()
                            local cost = tonumber(allowedEgg.PriceNum) or 0
                            if cost > 0 and cash >= cost then
                                local purchased = attemptPurchaseFromInfo(allowedEgg, true)
                                if purchased then waitUntilNoEgg(10) end
                            end
                        end
                    end
                end
            end

            task.wait(math.max(0.05, pollInterval * 0.5))
        end
    end

    -- Create the Rayfield toggle
    StatusTab:CreateToggle({
        Name = "Auto Spawn+Buy Eggs",
        CurrentValue = false,
        Flag = "AutoSpawnBuyEggs",
        Callback = function(val)
            autoEnabled = val
            if autoEnabled then
                if not autoThread or coroutine.status(autoThread) ~= "running" then
                    autoThread = spawn(function()
                        autoSpawnBuyLoop()
                    end)
                end
            end
        end
    })
end
