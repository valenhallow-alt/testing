-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a minimal, blank window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

pcall(function() Rayfield:LoadConfiguration() end)

----------------------------------------------------------------
-- Main tab with robust Auto Spin+Buy Egg
----------------------------------------------------------------

local MainTab = Window:CreateTab("Main", 4483362458)
local MainSection = MainTab:CreateSection("Auto Features")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Helper to safely get the remote by name
local function getRemote(name)
    local ok, remote = pcall(function()
        return ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Internals"):WaitForChild("Skeleton"):WaitForChild("Conduit"):WaitForChild("Instances"):WaitForChild(name)
    end)
    if ok then return remote end
    return nil
end

local requestEggRemote = getRemote("_requestEgg")
local purchaseEggRemote = getRemote("_purchaseEgg")

-- Generic safe reader for common value containers
local function readValue(obj)
    if not obj then return nil end
    if typeof(obj) == "Instance" then
        if obj:IsA("StringValue") or obj:IsA("IntValue") or obj:IsA("NumberValue") or obj:IsA("BoolValue") then
            return obj.Value
        end
        if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
            return obj.Text
        end
        -- Some UI frameworks store text in a child named "Text" or "Value"
        local v = obj:FindFirstChild("Value") or obj:FindFirstChild("Text")
        if v and (v:IsA("StringValue") or v:IsA("IntValue") or v:IsA("NumberValue")) then
            return v.Value
        end
        -- Try common properties safely
        local ok, val = pcall(function() return obj.Value end)
        if ok and val ~= nil then return val end
        ok, val = pcall(function() return obj.Text end)
        if ok and val ~= nil then return val end
    end
    return nil
end

-- Parse an Eggtag instance and return both the instance and parsed info
local function parseEggtagInstance(tag)
    if not tag or not tag.Parent then return nil end
    local model = tag.Parent
    local modelName = tostring(model.Name or "")

    -- Container may be a child named "Container" or the tag itself
    local container = tag:FindFirstChild("Container") or tag

    -- Helper to find child ignoring case and searching descendants
    local function findChildIgnoreCase(parent, candidates)
        if not parent then return nil end
        for _, name in ipairs(candidates) do
            local c = parent:FindFirstChild(name)
            if c then return c end
        end
        for _, desc in ipairs(parent:GetDescendants()) do
            local lname = tostring(desc.Name):lower()
            for _, name in ipairs(candidates) do
                if lname == name:lower() or lname:match(name:lower()) then
                    return desc
                end
            end
        end
        return nil
    end

    local rarityObj = findChildIgnoreCase(container, {"Rarity", "rarity", "RarityLabel", "rarityLabel"})
    local varietyObj = findChildIgnoreCase(container, {"Variety", "variety", "Type", "type", "VarietyLabel"})
    local priceObj = findChildIgnoreCase(container, {"Price", "price", "Cost", "cost"})

    local rarity = readValue(rarityObj)
    local variety = readValue(varietyObj)
    local price = readValue(priceObj)

    if type(rarity) == "string" then rarity = rarity:match("^%s*(.-)%s*$") end
    if type(variety) == "string" then variety = variety:match("^%s*(.-)%s*$") end

    -- If rarity/variety are still nil, try scanning descendants for likely text
    if (not rarity or rarity == "") and container then
        for _, v in ipairs(container:GetDescendants()) do
            local n = tostring(v.Name):lower()
            if n:match("rar") or n:match("rarity") then
                local val = readValue(v)
                if val and val ~= "" then
                    rarity = val
                    break
                end
            end
        end
    end
    if (not variety or variety == "") and container then
        for _, v in ipairs(container:GetDescendants()) do
            local n = tostring(v.Name):lower()
            if n:match("var") or n:match("type") then
                local val = readValue(v)
                if val and val ~= "" then
                    variety = val
                    break
                end
            end
        end
    end

    if modelName and modelName ~= "" and rarity and variety then
        local safeModelName = tostring(modelName):gsub("%s+", "_")
        local id = "entity_" .. safeModelName .. "_egg"
        return {
            tagInstance = tag,
            model = model,
            modelName = modelName,
            id = id,
            rarity = tostring(rarity),
            variety = tostring(variety),
            price = price
        }
    end

    return nil
end

-- Find any Eggtag in workspace and return parsed info (first found)
local function findEggInWorkspace()
    -- quick top-level scan
    for _, child in ipairs(Workspace:GetChildren()) do
        local tag = child:FindFirstChild("Eggtag")
        if tag then
            local info = parseEggtagInstance(tag)
            if info then return info end
        end
    end
    -- deeper scan
    for _, desc in ipairs(Workspace:GetDescendants()) do
        if desc.Name == "Eggtag" then
            local info = parseEggtagInstance(desc)
            if info then return info end
        end
    end
    return nil
end

-- Build args for remotes
local function buildRequestArgs()
    return {
        {
            __raw = true,
            data = {}
        }
    }
end

local function buildPurchaseArgs(info)
    return {
        {
            __raw = true,
            data = {
                id = info.id,
                rarity = info.rarity,
                variety = info.variety
            }
        }
    }
end

-- Wait helpers
local function waitForEggToAppear(timeout)
    timeout = timeout or 8
    local elapsed = 0
    local interval = 0.35
    while elapsed < timeout do
        local info = findEggInWorkspace()
        if info then return info end
        wait(interval)
        elapsed = elapsed + interval
    end
    return nil
end

local function waitForPriceToPopulate(info, timeout)
    timeout = timeout or 6
    local elapsed = 0
    local interval = 0.35
    while elapsed < timeout do
        if not info or not info.tagInstance or not info.tagInstance.Parent then return nil end
        -- re-parse the same tag to get updated price/fields
        local refreshed = parseEggtagInstance(info.tagInstance)
        if refreshed and refreshed.price and tostring(refreshed.price) ~= "" then
            return refreshed
        end
        wait(interval)
        elapsed = elapsed + interval
    end
    return nil
end

-- Confirm purchase by checking that the egg's tag instance or model was removed or changed
local function waitForPurchaseConfirmation(info, timeout)
    timeout = timeout or 6
    local elapsed = 0
    local interval = 0.25
    -- If the tag instance is destroyed or parent changed, assume purchase/consumption
    while elapsed < timeout do
        if not info or not info.tagInstance then
            return true -- already gone
        end
        local ok, exists = pcall(function() return info.tagInstance.Parent ~= nil end)
        if not ok or not exists then
            return true
        end
        -- Some games may keep the tag but change its contents; check if model still has same name or price
        local current = parseEggtagInstance(info.tagInstance)
        if not current then
            return true
        end
        -- If price becomes nil or tag removed, treat as consumed
        wait(interval)
        elapsed = elapsed + interval
    end
    return false
end

-- Note: Auto Spin+Buy Egg toggle and its associated loop have been removed per request.
-- The rest of the script (egg parsing, remotes, helpers) remains intact so other UI/status code can use it.
