-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a minimal, blank window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867"
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- === Main tab with safe Auto Buy Egg toggle (targeted detection using workspace.<Name>.Eggtag) ===
do
    local MainTab = Window:CreateTab("Main", 4483362458)
    local MainSection = MainTab:CreateSection("Main")

    -- Add a status label to the UI so you can see what the script is doing
    local StatusLabel = MainTab:CreateLabel("Status: Idle", 4483362458, Color3.fromRGB(255,255,255), false)
    local function setStatus(text)
        pcall(function()
            StatusLabel:Set("Status: " .. tostring(text))
        end)
        print("[UnHub] " .. tostring(text))
    end

    -- Global flag used by the toggle loop
    _G.UnHub_AutoBuyEgg = _G.UnHub_AutoBuyEgg or false

    -- Internal state
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local LastEgg = nil -- { id=..., rarity=..., variety=..., sourceName=... }
    local purchaseRemote = nil
    local Conduit = nil
    local loopRunning = false

    -- Locate the purchase remote at the path you provided
    local function getPurchaseRemote()
        local ok, inst = pcall(function()
            return ReplicatedStorage
                :WaitForChild("Modules", 2)
                :WaitForChild("Internals", 2)
                :WaitForChild("Skeleton", 2)
                :WaitForChild("Conduit", 2)
                :WaitForChild("Instances", 2)
        end)
        if not ok or not inst then
            warn("[UnHub] getPurchaseRemote: couldn't find Conduit Instances path")
            setStatus("Remote path missing")
            return nil
        end
        local rem = inst:FindFirstChild("_purchaseEgg")
        if rem then
            setStatus("Found _purchaseEgg remote")
        else
            warn("[UnHub] getPurchaseRemote: _purchaseEgg remote not found in Instances")
            setStatus("_purchaseEgg not found")
        end
        return rem
    end

    -- Attempt to require the Skeleton module and attach Conduit listeners (lightweight)
    pcall(function()
        local ok, skeleton = pcall(function()
            return require(ReplicatedStorage.Modules.Internals.Skeleton)
        end)
        if ok and skeleton and skeleton.Conduit and type(skeleton.Conduit.Listen) == "function" then
            Conduit = skeleton.Conduit
            setStatus("Conduit found, attaching listeners")
            Conduit.Listen("_requestEgg", function(payload)
                if type(payload) == "table" and payload.data then
                    LastEgg = {
                        id = tostring(payload.data.id or payload.id or payload.dataId or payload.data.id),
                        rarity = tostring(payload.data.rarity or payload.rarity or "Basic"),
                        variety = tostring(payload.data.variety or payload.variety or "Normal"),
                        sourceName = "Conduit"
                    }
                    setStatus(string.format("Conduit _requestEgg -> id=%s rarity=%s variety=%s", LastEgg.id, LastEgg.rarity, LastEgg.variety))
                else
                    setStatus("_requestEgg received but payload missing data")
                end
            end)
            Conduit.Listen("_purchaseEgg", function(payload)
                if type(payload) == "table" and payload.data then
                    LastEgg = {
                        id = tostring(payload.data.id or payload.id or payload.dataId or payload.data.id),
                        rarity = tostring(payload.data.rarity or payload.rarity or "Basic"),
                        variety = tostring(payload.data.variety or payload.variety or "Normal"),
                        sourceName = "Conduit"
                    }
                    setStatus(string.format("Conduit _purchaseEgg -> id=%s rarity=%s variety=%s", LastEgg.id, LastEgg.rarity, LastEgg.variety))
                else
                    setStatus("_purchaseEgg received but payload missing data")
                end
            end)
        else
            warn("[UnHub] Skeleton.Conduit not available or doesn't expose Listen; using targeted workspace scan")
            setStatus("Conduit not available; using workspace scan")
        end
    end)

    -- Helper: extract egg data from the Eggtag.Container.Entity instance
    local function extractFromEntity(entityInst)
        if not entityInst or not entityInst:IsA("Instance") then return nil end

        -- 1) Attributes
        local function tryAttr(name)
            local ok, v = pcall(function() return entityInst:GetAttribute(name) end)
            if ok and v ~= nil then return tostring(v) end
            return nil
        end

        -- 2) Child ValueBase (StringValue, IntValue, etc.)
        local function tryChildValue(name)
            local c = entityInst:FindFirstChild(name)
            if c and c:IsA("ValueBase") then
                return tostring(c.Value)
            end
            for _, child in ipairs(entityInst:GetChildren()) do
                if child:IsA("ValueBase") and string.lower(child.Name) == string.lower(name) then
                    return tostring(child.Value)
                end
            end
            return nil
        end

        -- 3) Search text inside any BillboardGui/TextLabel under the Eggtag (if present)
        local function tryBillboardText(root)
            for _, d in ipairs(root:GetDescendants()) do
                if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
                    local txt = tostring(d.Text or "")
                    local id = txt:match("id[:%s]*([%w_%-%:]+)")
                    local rarity = txt:match("rarity[:%s]*([%w_%-%:]+)")
                    local variety = txt:match("variety[:%s]*([%w_%-%:]+)")
                    if id or rarity or variety then
                        return id, rarity, variety
                    end
                end
            end
            return nil, nil, nil
        end

        local id = tryAttr("id") or tryAttr("Id") or tryChildValue("id") or tryChildValue("Id") or tryChildValue("Name")
        local rarity = tryAttr("rarity") or tryChildValue("rarity") or tryChildValue("Rarity")
        local variety = tryAttr("variety") or tryChildValue("variety") or tryChildValue("Variety")

        -- If the entityInst has a parent billboard or similar, search its text
        local parentGui = entityInst.Parent
        if (not id or not rarity or not variety) and parentGui then
            local gId, gRarity, gVariety = tryBillboardText(parentGui)
            id = id or gId
            rarity = rarity or gRarity
            variety = variety or gVariety
        end

        if id and rarity and variety then
            return { id = tostring(id), rarity = tostring(rarity), variety = tostring(variety) }
        end

        return nil
    end

    -- Targeted workspace scan: find any child of workspace that has an "Eggtag" child
    -- then read Eggtag.Container.Entity. The parent's name is used as the egg name (Sanji, Frieren, etc).
    local function targetedWorkspaceScan()
        setStatus("Scanning workspace for Eggtag entries")
        for _, child in ipairs(workspace:GetChildren()) do
            -- quick filter: child must be a Model/Folder/Instance and have an "Eggtag" child
            local eggtag = child:FindFirstChild("Eggtag")
            if eggtag and eggtag:IsA("BillboardGui") or eggtag then
                -- We expect Eggtag.Container.Entity path
                local container = eggtag:FindFirstChild("Container") or (eggtag:FindFirstChildWhichIsA("Folder") and eggtag:FindFirstChildWhichIsA("Folder"))
                if container then
                    local entity = container:FindFirstChild("Entity") or container:FindFirstChildWhichIsA("Model") or container:FindFirstChildWhichIsA("Folder")
                    if entity then
                        -- Extract data from the entity instance
                        local data = extractFromEntity(entity)
                        if data then
                            data.sourceName = tostring(child.Name) -- the dynamic egg name (Sanji, Frieren, etc)
                            setStatus(string.format("Found egg at workspace.%s.Eggtag -> id=%s rarity=%s variety=%s", child.Name, data.id, data.rarity, data.variety))
                            LastEgg = data
                            return true
                        else
                            -- If entity didn't contain direct values, try searching Eggtag's descendants for text
                            -- (some games put the text on the BillboardGui itself)
                            local bId, bR, bV = nil, nil, nil
                            for _, d in ipairs(eggtag:GetDescendants()) do
                                if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
                                    local txt = tostring(d.Text or "")
                                    bId = bId or txt:match("id[:%s]*([%w_%-%:]+)")
                                    bR = bR or txt:match("rarity[:%s]*([%w_%-%:]+)")
                                    bV = bV or txt:match("variety[:%s]*([%w_%-%:]+)")
                                end
                            end
                            if bId and bR and bV then
                                LastEgg = { id = bId, rarity = bR, variety = bV, sourceName = tostring(child.Name) }
                                setStatus(string.format("Found egg via Eggtag text at workspace.%s -> id=%s rarity=%s variety=%s", child.Name, bId, bR, bV))
                                return true
                            end
                        end
                    end
                end
            end
        end
        setStatus("No Eggtag found in workspace children")
        return false
    end

    -- Build args table in the exact shape required by the remote
    local function buildArgs(egg)
        if not egg then return nil end
        return {
            {
                __raw = true,
                data = {
                    id = egg.id,
                    rarity = egg.rarity,
                    variety = egg.variety
                }
            }
        }
    end

    -- Debounced safe fire
    local lastFire = 0
    local FIRE_COOLDOWN = 1.5
    local function safeFirePurchase()
        if not purchaseRemote then
            purchaseRemote = getPurchaseRemote()
            if not purchaseRemote then
                warn("[UnHub] safeFirePurchase: purchaseRemote not available")
                setStatus("Purchase remote missing")
                return false
            end
        end
        if not LastEgg then
            warn("[UnHub] safeFirePurchase: no LastEgg data to purchase")
            setStatus("No egg data to purchase")
            return false
        end
        if tick() - lastFire < FIRE_COOLDOWN then
            setStatus("Cooldown active, skipping fire")
            return false
        end
        lastFire = tick()
        local args = buildArgs(LastEgg)
        if not args then
            warn("[UnHub] safeFirePurchase: failed to build args")
            setStatus("Failed to build args")
            return false
        end
        local ok, err = pcall(function() purchaseRemote:FireServer(unpack(args)) end)
        if ok then
            setStatus(string.format("Fired purchase for id=%s rarity=%s variety=%s (source=%s)", LastEgg.id, LastEgg.rarity, LastEgg.variety, tostring(LastEgg.sourceName)))
        else
            warn("[UnHub] safeFirePurchase: FireServer failed:", err)
            setStatus("FireServer failed")
        end
        return ok
    end

    -- Single background loop that reacts to toggle state; prevents multiple loops
    local function startAutoBuyLoop()
        if loopRunning then
            print("[UnHub] startAutoBuyLoop: loop already running")
            return
        end
        loopRunning = true
        setStatus("AutoBuy loop starting")
        spawn(function()
            while _G.UnHub_AutoBuyEgg do
                -- prefer event-driven data if Conduit provided it
                if LastEgg and LastEgg.sourceName == "Conduit" then
                    pcall(safeFirePurchase)
                    task.wait(1.5)
                else
                    -- targeted workspace scan (fast: only top-level children)
                    local found = false
                    pcall(function() found = targetedWorkspaceScan() end)
                    if found then
                        pcall(safeFirePurchase)
                    end
                    -- wait a short time but not too short; adjust as needed
                    task.wait(2.5)
                end
            end
            loopRunning = false
            setStatus("AutoBuy loop stopped")
        end)
    end

    -- Create the Auto Buy Egg toggle
    local AutoBuyToggle = MainTab:CreateToggle({
        Name = "Auto Buy Egg",
        CurrentValue = false,
        Flag = "AutoBuyEgg",
        Callback = function(Value)
            _G.UnHub_AutoBuyEgg = Value
            if Value then
                setStatus("Toggle enabled: Auto Buy Egg ON")
                purchaseRemote = getPurchaseRemote()
                startAutoBuyLoop()
            else
                setStatus("Toggle disabled: Auto Buy Egg OFF")
            end
        end,
    })
end
-- === End Main tab ===

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)
