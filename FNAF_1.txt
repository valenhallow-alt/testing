-- UnHub Egg Buyer — final full script
-- Features:
-- * Guarded Rayfield loader
-- * Auto-scan watchers (polling)
-- * Conduit listeners
-- * Auto Buy toggle
-- * Mutation dropdown (multi-select) using Rayfield API (MultipleOptions = true)
-- * If rarity not allowed, auto-spawn new egg via _requestEgg remote
-- * Minimal console output controlled by DEBUG

local DEBUG = false
local function dbg(...) if DEBUG then print("[UnHub]", ...) end end

-- Destroy previous Rayfield instance if present
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Safe Rayfield loader
local Rayfield = nil
do
    local ok, libOrErr = pcall(function()
        local raw = game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library')
        if type(raw) ~= "string" or raw == "" then error("empty library response") end
        local fn, loadErr = loadstring(raw)
        if not fn then error("loadstring failed: "..tostring(loadErr)) end
        local ok2, lib = pcall(fn)
        if not ok2 then error("executing library failed: "..tostring(lib)) end
        return lib
    end)
    if ok and type(libOrErr) == "table" then
        Rayfield = libOrErr
        _G.RayfieldInstance = Rayfield
        dbg("Rayfield loaded")
    else
        Rayfield = nil
    end
end

if not Rayfield or type(Rayfield.CreateWindow) ~= "function" then
    return
end

-- Create Rayfield window
local okWindow, Window = pcall(function()
    return Rayfield:CreateWindow({
        Name = "UnHub (Egg Buyer)",
        FileName = "UnHub_EggBuyer",
        Icon = 0,
        Theme = "DarkBlue",
        ToggleUIKeybind = "H",
        ConfigurationSaving = { Enabled = true, FolderName = nil, FileName = "UnHub_EggBuyer" },
        Discord = { Enabled = false, Invite = "", RememberJoins = true },
        KeySystem = false,
        KeySettings = { Title = "UnHub", Subtitle = "Key", Note = "", FileName = "Key", SaveKey = false, GrabKeyFromSite = false, Key = {} }
    })
end)
if not okWindow or not Window then return end

-- Resolve parent GUI safely for the small toggle button
local parentGui = nil
pcall(function()
    if type(Rayfield.GetParent) == "function" then
        local p = Rayfield:GetParent()
        if p and p.Parent and p.Parent:IsA("Instance") then parentGui = p.Parent end
    end
end)
if not parentGui or not parentGui:IsA("Instance") then parentGui = game:GetService("CoreGui") end

-- Minimal UI toggle button (guarded)
do
    local ST = Instance.new("ScreenGui")
    ST.Name = "Toggle UnHub"
    ST.ResetOnSpawn = false
    ST.Parent = parentGui

    local T = Instance.new("ImageButton")
    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0,0,0)
    T.Position = UDim2.new(0,30,0.08,0)
    T.Size = UDim2.new(0,50,0,50)
    T.Image = "rbxassetid://112045743772867"
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    local Corner = Instance.new("UICorner")
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0,8)

    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function()
            if type(Rayfield.GetEnable) == "function" then return Rayfield:GetEnable() end
            return false
        end)
        if ok then
            pcall(function()
                if type(Rayfield.SetEnable) == "function" then Rayfield:SetEnable(not enabled) end
            end)
        end
    end)
end

-- === Main tab: detection + purchase + Mutation dropdown ===
do
    local MainTab = Window:CreateTab("Main", 4483362458)
    local MainSection = MainTab:CreateSection("Main")

    local StatusLabel = MainTab:CreateLabel("Status: Idle", 4483362458, Color3.fromRGB(255,255,255), false)
    local function setStatus(text)
        pcall(function() StatusLabel:Set("Status: " .. tostring(text)) end)
        dbg("STATUS:", text)
    end

    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    _G.UnHub_AutoBuyEgg = _G.UnHub_AutoBuyEgg or false

    local LastEgg = nil
    local purchaseRemote = nil
    local requestEggRemote = nil
    local Conduit = nil
    local loopRunning = false

    -- Allowed rarities set (updated by dropdown)
    local AllowedRarities = {} -- set: AllowedRarities["Normal"] = true

    -- Dropdown options (includes Secret)
    local MUTATION_OPTIONS = { "Normal", "Golden", "Diamond", "Glitch", "Galaxy", "????", "Secret" }

    -- Helper: set AllowedRarities from list
    local function setAllowedRarities(list)
        AllowedRarities = {}
        if type(list) == "table" then
            for _, v in ipairs(list) do
                if type(v) == "string" then AllowedRarities[tostring(v)] = true end
            end
        end
        dbg("Allowed rarities set:", table.concat(list or {}, ","))
    end

    -- Initialize default allowed rarities (all selected by default)
    setAllowedRarities(MUTATION_OPTIONS)

    -- Remotes lookup
    local function getInstancesFolder()
        local ok, inst = pcall(function()
            return ReplicatedStorage
                :WaitForChild("Modules", 2)
                :WaitForChild("Internals", 2)
                :WaitForChild("Skeleton", 2)
                :WaitForChild("Conduit", 2)
                :WaitForChild("Instances", 2)
        end)
        if not ok or not inst then
            setStatus("Remote path missing")
            return nil
        end
        return inst
    end

    local function getPurchaseRemote()
        if purchaseRemote then return purchaseRemote end
        local inst = getInstancesFolder()
        if not inst then return nil end
        purchaseRemote = inst:FindFirstChild("_purchaseEgg")
        if not purchaseRemote then setStatus("_purchaseEgg not found") end
        return purchaseRemote
    end

    local function getRequestEggRemote()
        if requestEggRemote then return requestEggRemote end
        local inst = getInstancesFolder()
        if not inst then return nil end
        requestEggRemote = inst:FindFirstChild("_requestEgg")
        if not requestEggRemote then setStatus("_requestEgg not found") end
        return requestEggRemote
    end

    local function requestNewEgg()
        local rem = getRequestEggRemote()
        if not rem then return false end
        local args = { { __raw = true, data = {} } }
        local ok, err = pcall(function()
            if type(rem.FireServer) == "function" then rem:FireServer(unpack(args))
            elseif type(rem.InvokeServer) == "function" then rem:InvokeServer(unpack(args))
            else error("No known fire method on request remote") end
        end)
        if ok then
            setStatus("Requested new egg")
            return true
        else
            setStatus("Request new egg failed")
            dbg("requestNewEgg error:", err)
            return false
        end
    end

    -- Conduit listeners (capture payloads)
    pcall(function()
        local ok, skeleton = pcall(function() return require(ReplicatedStorage.Modules.Internals.Skeleton) end)
        if ok and skeleton and skeleton.Conduit and type(skeleton.Conduit.Listen) == "function" then
            Conduit = skeleton.Conduit
            setStatus("Conduit found; attaching listeners")
            Conduit.Listen("_requestEgg", function(payload)
                if type(payload) == "table" then
                    local dataTable = (type(payload.data) == "table") and payload.data or payload
                    local capturedId = tostring(dataTable.id or dataTable.entity_id or dataTable.entity or dataTable.display_name or "")
                    local capturedRarity = tostring(dataTable.rarity or "Normal")
                    local capturedVariety = tostring(dataTable.variety or "Normal")
                    local capturedSource = tostring(dataTable.source or dataTable.display_name or payload.display_name or LastEgg and LastEgg.source or "")
                    LastEgg = { id = capturedId, rarity = capturedRarity, variety = capturedVariety, source = capturedSource }
                    setStatus("Conduit _requestEgg captured")
                    dbg("_requestEgg payload keys:", (type(dataTable)=="table" and table.concat((function() local t={} for k,_ in pairs(dataTable) do table.insert(t,k) end return t end)(), ",") or tostring(dataTable)))
                end
            end)
            Conduit.Listen("_purchaseEgg", function(payload)
                if type(payload) == "table" then
                    local dataTable = (type(payload.data) == "table") and payload.data or payload
                    local capturedId = tostring(dataTable.id or dataTable.entity_id or dataTable.entity or dataTable.display_name or "")
                    local capturedRarity = tostring(dataTable.rarity or "Normal")
                    local capturedVariety = tostring(dataTable.variety or "Normal")
                    local capturedSource = tostring(dataTable.source or dataTable.display_name or payload.display_name or LastEgg and LastEgg.source or "")
                    LastEgg = { id = capturedId, rarity = capturedRarity, variety = capturedVariety, source = capturedSource }
                    setStatus("Conduit _purchaseEgg captured")
                    dbg("_purchaseEgg payload keys:", (type(dataTable)=="table" and table.concat((function() local t={} for k,_ in pairs(dataTable) do table.insert(t,k) end return t end)(), ",") or tostring(dataTable)))
                end
            end)
        else
            setStatus("Conduit not available; using workspace scan")
        end
    end)

    -- Extractor
    local function extractFromEntity(entityInst)
        if not entityInst or not entityInst:IsA("Instance") then return nil end
        if entityInst:IsA("TextLabel") or entityInst:IsA("TextButton") or entityInst:IsA("TextBox") then
            local entText = tostring(entityInst.Text or "")
            local id = entText:match("([%w_%-]+_egg)") or entText:match("([%w_%-]+)")
            local container = entityInst.Parent
            local rarity, variety = nil, nil
            if container then
                local r = container:FindFirstChild("Rarity")
                local v = container:FindFirstChild("Variety")
                if r and (r:IsA("TextLabel") or r:IsA("TextButton") or r:IsA("TextBox")) then rarity = tostring(r.Text or "") end
                if v and (v:IsA("TextLabel") or v:IsA("TextButton") or v:IsA("TextBox")) then variety = tostring(v.Text or "") end
            end
            local function trim(s) return (tostring(s):gsub("^%s*(.-)%s*$", "%1")) end
            id = id and trim(id) or nil
            rarity = rarity and trim(rarity) or nil
            variety = variety and trim(variety) or nil
            if id and rarity and variety then return { id = id, rarity = rarity, variety = variety } end
            if id or rarity or variety then return { id = id or "", rarity = rarity or "Normal", variety = variety or "Normal" } end
            return nil
        end
        local function tryAttr(n)
            local ok, v = pcall(function() return entityInst:GetAttribute(n) end)
            if ok and v ~= nil then return tostring(v) end
            return nil
        end
        local function tryChildValue(n)
            local c = entityInst:FindFirstChild(n)
            if c and c:IsA("ValueBase") then return tostring(c.Value) end
            for _, ch in ipairs(entityInst:GetChildren()) do
                if ch:IsA("ValueBase") and string.lower(ch.Name) == string.lower(n) then return tostring(ch.Value) end
            end
            return nil
        end
        local id = tryAttr("id") or tryChildValue("id") or tryChildValue("Name")
        local rarity = tryAttr("rarity") or tryChildValue("rarity")
        local variety = tryAttr("variety") or tryChildValue("variety")
        if id and rarity and variety then return { id = tostring(id), rarity = tostring(rarity), variety = tostring(variety) } end
        return nil
    end

    -- Targeted workspace scan
    local function targetedWorkspaceScan()
        setStatus("Scanning workspace for egg billboards")
        for _, child in ipairs(workspace:GetChildren()) do
            if child:IsA("Model") or child:IsA("Folder") or child:IsA("BasePart") then
                local eggtag = child:FindFirstChild("Eggtag")
                if eggtag and eggtag:IsA("BillboardGui") then
                    local container = eggtag:FindFirstChild("Container") or eggtag:FindFirstChildWhichIsA("Frame") or eggtag:FindFirstChildWhichIsA("Folder")
                    if container then
                        local entity = container:FindFirstChild("Entity") or container:FindFirstChildWhichIsA("TextLabel") or container:FindFirstChildWhichIsA("Model")
                        if entity then
                            local data = extractFromEntity(entity)
                            if data then
                                data.source = tostring(child.Name)
                                LastEgg = data
                                setStatus(string.format("Found egg: source=%s rarity=%s variety=%s", data.source, data.rarity, data.variety))
                                return true
                            end
                        end
                    end
                else
                    for _, c2 in ipairs(child:GetChildren()) do
                        if c2:IsA("BillboardGui") or string.find(string.lower(c2.Name or ""), "egg") then
                            local container = c2:FindFirstChild("Container") or c2:FindFirstChildWhichIsA("Frame") or c2:FindFirstChildWhichIsA("Folder")
                            if container then
                                local entity = container:FindFirstChild("Entity") or container:FindFirstChildWhichIsA("TextLabel") or container:FindFirstChildWhichIsA("Model")
                                if entity then
                                    local data = extractFromEntity(entity)
                                    if data then
                                        data.source = tostring(child.Name)
                                        LastEgg = data
                                        setStatus(string.format("Found egg: source=%s rarity=%s variety=%s", data.source, data.rarity, data.variety))
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        setStatus("No egg billboards found")
        return false
    end

    -- Build args (prefer source token)
    local function buildArgs(egg)
        if not egg then return nil end
        local function normalizeToken(token)
            if not token then return nil end
            token = tostring(token):gsub("^%s*(.-)%s*$", "%1")
            if token == "" then return nil end
            local inner = token:match("^entity_([%w_%-]+)_egg$")
            if inner then return inner end
            local simple = token:match("([%w_%-]+)")
            return simple or token
        end
        local preferred = nil
        if egg.source and tostring(egg.source) ~= "" and tostring(egg.source):lower() ~= "unknown" then preferred = normalizeToken(egg.source) end
        if not preferred then preferred = normalizeToken(egg.id) end
        if not preferred then preferred = normalizeToken(egg.variety) or normalizeToken(egg.rarity) or "unknown" end
        local finalId = "entity_" .. tostring(preferred) .. "_egg"
        return { { __raw = true, data = { id = finalId, rarity = tostring(egg.rarity or "Normal"), variety = tostring(egg.variety or "Normal") } } }
    end

    -- Check allowed rarity
    local function isRarityAllowed(rarity)
        if not rarity then return false end
        return AllowedRarities[tostring(rarity)] == true
    end

    -- Purchase logic with rarity check; if not allowed, request new egg instead
    local lastFire = 0
    local FIRE_COOLDOWN = 1.5

    local function safeFirePurchase()
        if not purchaseRemote then purchaseRemote = getPurchaseRemote() end
        if not purchaseRemote then setStatus("Purchase remote missing"); return false end
        if not LastEgg then setStatus("No egg data to purchase"); return false end
        if tick() - lastFire < FIRE_COOLDOWN then setStatus("Cooldown active"); return false end

        -- If rarity not allowed, request new egg and skip purchase
        if not isRarityAllowed(LastEgg.rarity) then
            setStatus(string.format("Rarity '%s' not allowed — requesting new egg", tostring(LastEgg.rarity)))
            pcall(requestNewEgg)
            return false
        end

        local args = buildArgs(LastEgg)
        if not args then setStatus("Failed to build args"); return false end

        setStatus("Attempting purchase: " .. tostring(LastEgg.source or LastEgg.id or "unknown"))
        lastFire = tick()
        local ok, err = pcall(function()
            if type(purchaseRemote.FireServer) == "function" then purchaseRemote:FireServer(unpack(args))
            elseif type(purchaseRemote.InvokeServer) == "function" then purchaseRemote:InvokeServer(unpack(args))
            else error("No known fire method on purchase remote") end
        end)

        if ok then
            setStatus("Purchase fired")
            -- After successful purchase, request a new egg if Auto Buy is enabled
            if _G.UnHub_AutoBuyEgg then
                task.delay(0.25, function() pcall(requestNewEgg) end)
            end
            return true
        else
            setStatus("Purchase attempt failed")
            dbg("safeFirePurchase error:", err)
            return false
        end
    end

    -- Loop runner
    local function startAutoBuyLoop()
        if loopRunning then return end
        loopRunning = true
        setStatus("AutoBuy loop starting")
        spawn(function()
            while _G.UnHub_AutoBuyEgg do
                if LastEgg and LastEgg.source and LastEgg.source ~= "" and LastEgg.source ~= "Unknown" then
                    pcall(safeFirePurchase)
                    task.wait(1.5)
                else
                    local ok, found = pcall(targetedWorkspaceScan)
                    if ok and found then pcall(safeFirePurchase) end
                    task.wait(2.5)
                end
            end
            loopRunning = false
            setStatus("AutoBuy loop stopped")
        end)
    end

    -- Automatic detection watchers (improved polling)
    do
        local childChildConns = {}
        local debounceTimestamps = {}
        local DEBOUNCE_SECONDS = 0.5
        local POLL_INTERVAL = 0.08
        local POLL_TIMEOUT = 1.5

        local function waitForEntityReady(eggtag)
            if not eggtag or not eggtag:IsA("BillboardGui") then return false end
            local container = eggtag:FindFirstChild("Container") or eggtag:FindFirstChildWhichIsA("Frame") or eggtag:FindFirstChildWhichIsA("Folder")
            if not container then return false end
            local entity = container:FindFirstChild("Entity") or container:FindFirstChildWhichIsA("TextLabel") or container:FindFirstChildWhichIsA("Model")
            if not entity then return false end
            local start = tick()
            while tick() - start <= POLL_TIMEOUT do
                if entity:IsA("TextLabel") or entity:IsA("TextButton") or entity:IsA("TextBox") then
                    local txt = tostring(entity.Text or "")
                    if txt ~= "" and not txt:match("^%s*$") then return true end
                end
                for _, ch in ipairs(entity:GetChildren()) do
                    if ch:IsA("ValueBase") then
                        local v = tostring(ch.Value or "")
                        if v ~= "" and not v:match("^%s*$") then return true end
                    end
                end
                local ok, attrId = pcall(function() return entity:GetAttribute("id") end)
                if ok and attrId and tostring(attrId) ~= "" then return true end
                task.wait(POLL_INTERVAL)
            end
            return false
        end

        local function tryScanChild(child)
            if not child or not child:IsA("Instance") then return end
            local name = tostring(child.Name or "")
            local last = debounceTimestamps[name] or 0
            if tick() - last < DEBOUNCE_SECONDS then return end
            debounceTimestamps[name] = tick()

            local eggtag = child:FindFirstChild("Eggtag")
            if eggtag and eggtag:IsA("BillboardGui") then
                task.spawn(function()
                    local okReady, ready = pcall(waitForEntityReady, eggtag)
                    if okReady and ready then
                        local ok, found = pcall(targetedWorkspaceScan)
                        if ok and found then
                            if _G.UnHub_AutoBuyEgg then pcall(safeFirePurchase) else setStatus("Egg detected (auto-scan) — Auto Buy is OFF") end
                        end
                    else
                        pcall(function()
                            local ok2, found2 = pcall(targetedWorkspaceScan)
                            if ok2 and found2 and _G.UnHub_AutoBuyEgg then pcall(safeFirePurchase) end
                        end)
                    end
                end)
                return
            end

            for _, c2 in ipairs(child:GetChildren()) do
                if c2:IsA("BillboardGui") or string.find(string.lower(c2.Name or ""), "egg") then
                    task.spawn(function()
                        local okReady, ready = pcall(waitForEntityReady, c2)
                        if okReady and ready then
                            local ok, found = pcall(targetedWorkspaceScan)
                            if ok and found then
                                if _G.UnHub_AutoBuyEgg then pcall(safeFirePurchase) else setStatus("Egg detected (auto-scan) — Auto Buy is OFF") end
                            end
                        else
                            pcall(function()
                                local ok2, found2 = pcall(targetedWorkspaceScan)
                                if ok2 and found2 and _G.UnHub_AutoBuyEgg then pcall(safeFirePurchase) end
                            end)
                        end
                    end)
                    return
                end
            end
        end

        local function attachChildChildListener(child)
            if not child or not child:IsA("Instance") then return end
            if childChildConns[child] then return end
            local conn = child.ChildAdded:Connect(function()
                task.defer(function() tryScanChild(child) end)
            end)
            childChildConns[child] = conn
        end

        for _, c in ipairs(workspace:GetChildren()) do attachChildChildListener(c) end

        local workspaceChildConn = workspace.ChildAdded:Connect(function(child)
            attachChildChildListener(child)
            task.defer(function() tryScanChild(child) end)
        end)

        local workspaceDescConn = workspace.DescendantAdded:Connect(function(desc)
            if not desc or not desc:IsA("BillboardGui") then return end
            local top = desc
            while top and top.Parent and top.Parent ~= workspace do top = top.Parent end
            if top and top.Parent == workspace then task.defer(function() tryScanChild(top) end) end
        end)

        _G.UnHub_AutoBuyEgg_Watchers = {
            workspaceChildConn = workspaceChildConn,
            workspaceDescConn = workspaceDescConn,
            childChildConns = childChildConns,
        }

        setStatus("Workspace watchers attached (auto-scan enabled)")
    end

    -- UI: Auto Buy toggle
    MainTab:CreateToggle({
        Name = "Auto Buy Egg",
        CurrentValue = false,
        Flag = "AutoBuyEgg",
        Callback = function(Value)
            _G.UnHub_AutoBuyEgg = Value
            if Value then
                setStatus("Toggle enabled: Auto Buy ON")
                purchaseRemote = getPurchaseRemote()
                requestEggRemote = getRequestEggRemote()
                startAutoBuyLoop()
            else
                setStatus("Toggle disabled: Auto Buy OFF")
            end
        end,
    })

    -- UI: Mutation dropdown (multi-select) using Rayfield API
    local Dropdown = MainTab:CreateDropdown({
        Name = "Mutation",
        Options = MUTATION_OPTIONS,
        CurrentOption = MUTATION_OPTIONS, -- default: all selected
        MultipleOptions = true,           -- enable multi-select
        Flag = "MutationDropdown",
        Callback = function(selectedOptions)
            if type(selectedOptions) == "table" then
                setAllowedRarities(selectedOptions)
                setStatus("Allowed mutations updated")
            else
                setAllowedRarities({})
                setStatus("Allowed mutations cleared")
            end
        end,
    })

    -- Select All / Clear buttons using Dropdown:Set
    MainTab:CreateButton({
        Name = "Select All Mutations",
        Callback = function()
            if Dropdown and type(Dropdown.Set) == "function" then
                pcall(function() Dropdown:Set(MUTATION_OPTIONS) end)
            else
                setAllowedRarities(MUTATION_OPTIONS)
            end
            setStatus("All mutations selected")
        end
    })

    MainTab:CreateButton({
        Name = "Clear All Mutations",
        Callback = function()
            if Dropdown and type(Dropdown.Set) == "function" then
                pcall(function() Dropdown:Set({}) end)
            else
                setAllowedRarities({})
            end
            setStatus("All mutations cleared")
        end
    })

    -- Initialize AllowedRarities from CurrentOption (if Rayfield saved config restored it)
    task.defer(function()
        task.wait(0.05)
        local initial = MUTATION_OPTIONS
        if Dropdown and type(Dropdown.Get) == "function" then
            local ok, val = pcall(function() return Dropdown:Get() end)
            if ok and type(val) == "table" and #val > 0 then initial = val end
        else
            -- try reading saved flag via Window.Flags if available
            pcall(function()
                if Window.Flags and Window.Flags.MutationDropdown and type(Window.Flags.MutationDropdown) == "table" then
                    initial = Window.Flags.MutationDropdown
                end
            end)
        end
        setAllowedRarities(initial)
    end)
end

-- Load configuration
pcall(function() Rayfield:LoadConfiguration() end)
