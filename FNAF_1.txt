-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a minimal, blank window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    -- Parent to the same UI context Rayfield uses so it appears alongside the Rayfield UI
    -- If Rayfield:GetParent() or its parent is nil, fall back to CoreGui
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867" -- replace with your decal id if desired
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    -- Toggle Rayfield visibility on click
    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- === Added: Main tab with Auto Buy Egg toggle (with dynamic detection & purchase) ===
do
    local MainTab = Window:CreateTab("Main", 4483362458)
    local MainSection = MainTab:CreateSection("Main")

    -- Global flag used by the toggle loop
    _G.UnHub_AutoBuyEgg = _G.UnHub_AutoBuyEgg or false

    -- Helper: locate the purchase remote at the exact path provided
    local function getPurchaseRemote()
        local ok, conduitInstances = pcall(function()
            return game:GetService("ReplicatedStorage")
                :WaitForChild("Modules", 2)
                :WaitForChild("Internals", 2)
                :WaitForChild("Skeleton", 2)
                :WaitForChild("Conduit", 2)
                :WaitForChild("Instances", 2)
        end)
        if not ok or not conduitInstances then return nil end
        local rem = conduitInstances:FindFirstChild("_purchaseEgg")
        return rem
    end

    -- Helper: try to extract fields from an Instance using multiple heuristics
    local function extractEggDataFromInstance(inst)
        if not inst or not inst:IsA("Instance") then return nil end

        local function tryAttr(name)
            local ok, v = pcall(function() return inst:GetAttribute(name) end)
            if ok and v ~= nil then return tostring(v) end
            return nil
        end

        local function tryChildValue(name)
            -- direct child with ValueBase
            local c = inst:FindFirstChild(name)
            if c and c:IsA("ValueBase") then
                return tostring(c.Value)
            end
            -- case-insensitive search among children
            for _, child in ipairs(inst:GetChildren()) do
                if child:IsA("ValueBase") and string.lower(child.Name) == string.lower(name) then
                    return tostring(child.Value)
                end
            end
            return nil
        end

        local function tryGuiTextSearch(root)
            for _, d in ipairs(root:GetDescendants()) do
                if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
                    local txt = tostring(d.Text or "")
                    -- patterns like "id: entity_Piccolo_egg" or "rarity: Basic"
                    local id = txt:match("id[:%s]*([%w_%-%:]+)")
                    local rarity = txt:match("rarity[:%s]*([%w_%-%:]+)")
                    local variety = txt:match("variety[:%s]*([%w_%-%:]+)")
                    if id or rarity or variety then
                        return id, rarity, variety
                    end
                end
            end
            return nil, nil, nil
        end

        -- 1) Attributes
        local id = tryAttr("id") or tryAttr("Id") or tryAttr("egg_id") or tryAttr("eggId")
        local rarity = tryAttr("rarity") or tryAttr("Rarity")
        local variety = tryAttr("variety") or tryAttr("Variety")

        -- 2) Child Value objects
        id = id or tryChildValue("id") or tryChildValue("Id") or tryChildValue("egg_id") or tryChildValue("Name")
        rarity = rarity or tryChildValue("rarity") or tryChildValue("Rarity")
        variety = variety or tryChildValue("variety") or tryChildValue("Variety")

        -- 3) GUI text (BillboardGui etc.)
        if (not id or id == "") and inst:FindFirstChildOfClass("BillboardGui") then
            local gId, gRarity, gVariety = tryGuiTextSearch(inst)
            id = id or gId
            rarity = rarity or gRarity
            variety = variety or gVariety
        end

        -- 4) If instance has a child named "data" that is a table-like Value (StringValue with JSON-ish text)
        local dataChild = inst:FindFirstChild("data")
        if (not id or not rarity or not variety) and dataChild and dataChild:IsA("StringValue") then
            local txt = dataChild.Value or ""
            -- try to extract tokens from JSON-like string
            local jId = txt:match('"id"%s*:%s*"(.-)"') or txt:match("'id'%s*:%s*'(.-)'")
            local jRarity = txt:match('"rarity"%s*:%s*"(.-)"') or txt:match("'rarity'%s*:%s*'(.-)'")
            local jVariety = txt:match('"variety"%s*:%s*"(.-)"') or txt:match("'variety'%s*:%s*'(.-)'")
            id = id or jId
            rarity = rarity or jRarity
            variety = variety or jVariety
        end

        -- 5) Fallback to name parsing (last resort)
        if not id or id == "" then
            local n = inst.Name or ""
            if n:lower():find("egg") then
                local token = n:match("([%w_%-]+_egg)") or n:match("([%w_%-]+)")
                if token then id = token end
            end
        end

        if id and rarity and variety then
            return {
                id = tostring(id),
                rarity = tostring(rarity),
                variety = tostring(variety)
            }
        end

        return nil
    end

    -- Heuristic: scan likely places for egg objects and return first match
    local function findEggInWorld()
        local candidates = { workspace }
        if workspace:FindFirstChild("Plots") then table.insert(candidates, workspace.Plots) end
        if workspace:FindFirstChild("Shop") then table.insert(candidates, workspace.Shop) end
        if workspace:FindFirstChild("EggShop") then table.insert(candidates, workspace.EggShop) end

        for _, root in ipairs(candidates) do
            for _, obj in ipairs(root:GetDescendants()) do
                local name = (obj.Name or ""):lower()
                if name:find("egg") or name:find("conveyor") or name:find("shop") or obj:FindFirstChild("Essentials") or obj:FindFirstChild("ConveyorVisual") then
                    local data = extractEggDataFromInstance(obj)
                    if data then
                        return data, obj
                    end
                end
            end
        end

        -- final fallback: scan workspace for any instance with attributes that look like egg data
        for _, obj in ipairs(workspace:GetDescendants()) do
            local data = extractEggDataFromInstance(obj)
            if data then return data, obj end
        end

        return nil, nil
    end

    -- Build args table in the exact shape you provided
    local function buildArgsTable(eggData)
        if not eggData then return nil end
        local args = {
            {
                __raw = true,
                data = {
                    id = eggData.id,
                    rarity = eggData.rarity,
                    variety = eggData.variety
                }
            }
        }
        return args
    end

    -- Main attempt function used by the AutoBuy loop
    local function attemptAutoBuy()
        local purchaseRemote = getPurchaseRemote()
        if not purchaseRemote then return false end

        -- Try to find egg data in world
        local eggData, eggInstance = findEggInWorld()

        -- If not found in world, try PlayerGui text heuristics
        if not eggData then
            local player = game:GetService("Players").LocalPlayer
            if player and player:FindFirstChild("PlayerGui") then
                for _, gui in ipairs(player.PlayerGui:GetDescendants()) do
                    if gui:IsA("TextLabel") or gui:IsA("TextButton") or gui:IsA("TextBox") then
                        local txt = tostring(gui.Text or "")
                        local id = txt:match("id[:%s]*([%w_%-%:]+)")
                        local rarity = txt:match("rarity[:%s]*([%w_%-%:]+)")
                        local variety = txt:match("variety[:%s]*([%w_%-%:]+)")
                        if id and rarity and variety then
                            eggData = { id = id, rarity = rarity, variety = variety }
                            break
                        end
                    end
                end
            end
        end

        if eggData then
            local args = buildArgsTable(eggData)
            if args then
                pcall(function()
                    purchaseRemote:FireServer(unpack(args))
                end)
                return true
            end
        end

        return false
    end

    -- Create the Auto Buy Egg toggle
    local AutoBuyToggle = MainTab:CreateToggle({
        Name = "Auto Buy Egg",
        CurrentValue = false,
        Flag = "AutoBuyEgg",
        Callback = function(Value)
            _G.UnHub_AutoBuyEgg = Value

            if Value then
                spawn(function()
                    while _G.UnHub_AutoBuyEgg do
                        local ok, res = pcall(attemptAutoBuy)
                        -- res true if a purchase attempt was made (no guarantee of success)
                        -- keep loop gentle to avoid spamming; adjust wait as needed
                        wait(1)
                    end
                end)
            end
        end,
    })
end
-- === End added Main tab ===

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)
