-- Full Macro + GUID + Placement watcher + Rayfield UI script
-- Paste into a LocalScript or run via your executor. This file combines:
-- 1) Rayfield UI for macros
-- 2) Separate recording ScreenGui
-- 3) Macro recording/playback system (fires MacroEvent)
-- 4) MacroGuidHelper (scans for GUIDs and wraps spawn remote)
-- 5) TowerPlacementWatcher (captures placed towers and CFrames)
-- 6) Convenience API for macros to place towers by GUID + CFrame

-- ======= Configuration =======
local debugX = true

-- ======= Rayfield load =======
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Rayfield Example Window",
   Icon = 0,
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   Theme = "Default",
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil,
      FileName = "Big Hub"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided",
      FileName = "Key",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = {"Hello"}
   }
})

local Tab = Window:CreateTab("Main", 4483362458)
local Section = Tab:CreateSection("Macros")

-- ======= Services & locals =======
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = workspace
local LocalPlayer = Players.LocalPlayer

-- ======= Bindable event for macro playback and placement capture =======
local MacroEvent = Instance.new("BindableEvent")
MacroEvent.Name = "MacroEvent"
MacroEvent.Parent = ReplicatedStorage or workspace

-- ======= Macro storage & recording state =======
local Macros = {}           -- name -> { events = {...} }
local MacroNames = {}       -- list for dropdown
local CurrentMacro = nil

local isRecording = false
local recordingStart = 0
local currentRecording = {}
local inputConn = nil

-- ======= Helper: refresh dropdown =======
local MacroDropdown, MacroNameInput, PlayToggle -- forward refs

local function refreshMacroDropdown()
    MacroNames = {}
    for name, _ in pairs(Macros) do
        table.insert(MacroNames, name)
    end
    table.sort(MacroNames)
    if MacroDropdown then
        MacroDropdown:Refresh(MacroNames)
        if not CurrentMacro or not Macros[CurrentMacro] then
            CurrentMacro = MacroNames[1]
            if CurrentMacro then
                MacroDropdown:Set(CurrentMacro)
            end
        end
    end
end

local function saveMacro(name, events)
    if not name or name == "" then return false end
    Macros[name] = { events = events }
    refreshMacroDropdown()
    return true
end

local function deleteMacro(name)
    if not name or not Macros[name] then return false end
    Macros[name] = nil
    refreshMacroDropdown()
    return true
end

-- ======= Input recording handlers =======
local function onInputBegan(input, gameProcessed)
    if not isRecording then return end
    local t = tick() - recordingStart
    local record = {
        Type = "Began",
        UserInputType = input.UserInputType,
        KeyCode = input.KeyCode,
        Position = (input.Position and Vector2.new(input.Position.X, input.Position.Y)) or nil,
        Time = t,
        GameProcessed = gameProcessed
    }
    table.insert(currentRecording, record)
end

local function onInputEnded(input, gameProcessed)
    if not isRecording then return end
    local t = tick() - recordingStart
    local record = {
        Type = "Ended",
        UserInputType = input.UserInputType,
        KeyCode = input.KeyCode,
        Position = (input.Position and Vector2.new(input.Position.X, input.Position.Y)) or nil,
        Time = t,
        GameProcessed = gameProcessed
    }
    table.insert(currentRecording, record)
end

-- ======= Playback =======
local function playMacroByName(name, repeats)
    local macro = Macros[name]
    if not macro or not macro.events or #macro.events == 0 then return end

    coroutine.wrap(function()
        local events = macro.events
        for i, ev in ipairs(events) do
            local waitTime
            if i == 1 then
                waitTime = ev.Time
            else
                waitTime = ev.Time - events[i-1].Time
            end
            if waitTime and waitTime > 0 then
                task.wait(waitTime)
            end
            MacroEvent:Fire({
                Name = name,
                Index = i,
                Type = ev.Type,
                UserInputType = ev.UserInputType,
                KeyCode = ev.KeyCode,
                Position = ev.Position,
                GameProcessed = ev.GameProcessed,
                Timestamp = tick()
            })
        end

        if repeats and PlayToggle and PlayToggle.CurrentValue then
            task.wait(0.05)
            if PlayToggle.CurrentValue then
                playMacroByName(name, repeats)
            end
        end
    end)()
end

-- ======= Separate Recording GUI (ScreenGui) =======
local function createRecordingGui()
    local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui", 5)
    if not playerGui then return nil end
    local existing = playerGui:FindFirstChild("MacroRecordingGui")
    if existing then return existing end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MacroRecordingGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Name = "RecordingFrame"
    frame.Size = UDim2.new(0, 200, 0, 60)
    frame.Position = UDim2.new(0.5, -100, 0.06, 0)
    frame.AnchorPoint = Vector2.new(0.5, 0)
    frame.BackgroundColor3 = Color3.fromRGB(28, 28, 28)
    frame.BorderSizePixel = 0
    frame.Parent = screenGui

    local uicorner = Instance.new("UICorner")
    uicorner.CornerRadius = UDim.new(0, 8)
    uicorner.Parent = frame

    local dot = Instance.new("Frame")
    dot.Name = "Dot"
    dot.Size = UDim2.new(0, 14, 0, 14)
    dot.Position = UDim2.new(0, 12, 0.5, -7)
    dot.BackgroundColor3 = Color3.fromRGB(255, 75, 75)
    dot.BorderSizePixel = 0
    dot.Parent = frame

    local dotCorner = Instance.new("UICorner")
    dotCorner.CornerRadius = UDim.new(1, 0)
    dotCorner.Parent = dot

    local label = Instance.new("TextLabel")
    label.Name = "RecordingLabel"
    label.Size = UDim2.new(0, 110, 1, 0)
    label.Position = UDim2.new(0, 36, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = "Recording"
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 18
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = frame

    local stopBtn = Instance.new("TextButton")
    stopBtn.Name = "StopButton"
    stopBtn.Size = UDim2.new(0, 56, 0, 28)
    stopBtn.Position = UDim2.new(1, -68, 0.5, -14)
    stopBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    stopBtn.Text = "Stop"
    stopBtn.TextColor3 = Color3.fromRGB(255,255,255)
    stopBtn.Font = Enum.Font.Gotham
    stopBtn.TextSize = 14
    stopBtn.Parent = frame

    local stopCorner = Instance.new("UICorner")
    stopCorner.CornerRadius = UDim.new(0, 6)
    stopCorner.Parent = stopBtn

    frame.Active = true
    frame.Draggable = true

    local pulseConnection
    pulseConnection = RunService.Heartbeat:Connect(function()
        if not dot or not dot.Parent then
            if pulseConnection then pulseConnection:Disconnect() end
            return
        end
        local s = (math.sin(tick()*6) + 1) / 2
        local scale = 1 + s * 0.35
        dot.Size = UDim2.new(0, 14 * scale, 0, 14 * scale)
        dot.Position = UDim2.new(0, 12 - (7*(scale-1)), 0.5, -7 - (7*(scale-1)))
    end)

    stopBtn.MouseButton1Click:Connect(function()
        if isRecording then
            isRecording = false
            if inputConn then
                for _, c in ipairs(inputConn) do
                    if c and c.Disconnect then c:Disconnect() end
                end
                inputConn = nil
            end
            local name = MacroNameInput and MacroNameInput.CurrentValue or ""
            if name == nil or name == "" then
                name = "macro_" .. tostring(math.floor(tick()))
            end
            local ok = saveMacro(name, currentRecording)
            if ok then
                MacroDropdown:Refresh(MacroNames)
                MacroDropdown:Set(name)
                CurrentMacro = name
            end
            screenGui.Enabled = false
        end
    end)

    screenGui.Enabled = false
    return screenGui
end

local RecordingGui = createRecordingGui()

-- ======= Rayfield UI elements (no extra state boxes) =======
MacroDropdown = Tab:CreateDropdown({
    Name = "MacroSelect",
    Options = {},
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "MacroSelectFlag",
    Callback = function(Options)
        if type(Options) == "table" and #Options > 0 then
            CurrentMacro = Options[1]
            if MacroNameInput then MacroNameInput:Set(CurrentMacro) end
        else
            CurrentMacro = nil
        end
    end,
})

MacroNameInput = Tab:CreateInput({
    Name = "MacroName",
    CurrentValue = "",
    PlaceholderText = "macro_name",
    RemoveTextAfterFocusLost = false,
    Flag = "MacroNameFlag",
    Callback = function(Text) end,
})

local RecordStateLabel = Tab:CreateLabel("Idle", 4483362458, Color3.fromRGB(255,255,255), false)

local RecordButton = Tab:CreateButton({
    Name = "Record / Stop",
    Callback = function()
        if not isRecording then
            isRecording = true
            currentRecording = {}
            recordingStart = tick()
            inputConn = {}
            inputConn[1] = UserInputService.InputBegan:Connect(onInputBegan)
            inputConn[2] = UserInputService.InputEnded:Connect(onInputEnded)
            if RecordingGui then RecordingGui.Enabled = true end
            if RecordStateLabel then RecordStateLabel:Set("Recording...") end
        else
            isRecording = false
            if inputConn then
                for _, c in ipairs(inputConn) do
                    if c and c.Disconnect then c:Disconnect() end
                end
                inputConn = nil
            end
            local name = MacroNameInput and MacroNameInput.CurrentValue or ""
            if name == nil or name == "" then
                name = "macro_" .. tostring(math.floor(tick()))
            end
            local ok = saveMacro(name, currentRecording)
            if ok then
                MacroDropdown:Refresh(MacroNames)
                MacroDropdown:Set(name)
                CurrentMacro = name
            end
            if RecordingGui then RecordingGui.Enabled = false end
            if RecordStateLabel then RecordStateLabel:Set("Idle") end
        end
    end,
})

PlayToggle = Tab:CreateToggle({
    Name = "Play Macro (repeats)",
    CurrentValue = false,
    Flag = "PlayMacroToggle",
    Callback = function(Value)
        if Value then
            if CurrentMacro and Macros[CurrentMacro] then
                playMacroByName(CurrentMacro, true)
            else
                PlayToggle:Set(false)
            end
        end
    end,
})

local PlayOnceButton = Tab:CreateButton({
    Name = "Play Once",
    Callback = function()
        if CurrentMacro and Macros[CurrentMacro] then
            playMacroByName(CurrentMacro, false)
        end
    end,
})

local DeleteButton = Tab:CreateButton({
    Name = "Delete Selected Macro",
    Callback = function()
        if CurrentMacro and Macros[CurrentMacro] then
            deleteMacro(CurrentMacro)
            CurrentMacro = nil
            MacroDropdown:Refresh(MacroNames)
            MacroNameInput:Set("")
        end
    end,
})

local RefreshButton = Tab:CreateButton({
    Name = "Refresh Macros",
    Callback = function()
        refreshMacroDropdown()
    end,
})

Tab:CreateParagraph({Title = "Macros", Content = "Record keyboard/mouse input. Playback fires MacroEvent in ReplicatedStorage/workspace. Connect to it to perform actions on playback."})

-- ======= Expose macro API =======
_G.RayfieldMacros = {
    GetMacros = function() return Macros end,
    Play = function(name) playMacroByName(name, false) end,
    PlayLoop = function(name) playMacroByName(name, true) end,
    Delete = function(name) deleteMacro(name) end,
    Save = function(name, events) return saveMacro(name, events) end,
    MacroEvent = MacroEvent
}

refreshMacroDropdown()

-- ======= MacroGuidHelper (scans for GUIDs and finds Spawn remote) =======
local MacroGuidHelper = {}
MacroGuidHelper._guidMap = {}
MacroGuidHelper._equipped = {}
MacroGuidHelper._spawnRemote = nil
local uuidPattern = "%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x"

local function safeDescendants(root)
    local ok, res = pcall(function() return root:GetDescendants() end)
    if ok and type(res) == "table" then return res end
    return {}
end

local function scanRootForGuids(root)
    for _, obj in ipairs(safeDescendants(root)) do
        if obj:IsA("StringValue") and type(obj.Value) == "string" then
            local s = obj.Value
            for match in string.gmatch(s, uuidPattern) do
                MacroGuidHelper._guidMap[match] = { path = obj:GetFullName(), source = obj }
            end
        end
        if obj.GetAttributes then
            local ok, attrs = pcall(function() return obj:GetAttributes() end)
            if ok and type(attrs) == "table" then
                for k,v in pairs(attrs) do
                    if type(v) == "string" then
                        for match in string.gmatch(v, uuidPattern) do
                            MacroGuidHelper._guidMap[match] = { path = obj:GetFullName() .. " (Attribute:"..tostring(k)..")", source = obj }
                        end
                    end
                end
            end
        end
        if type(obj.Name) == "string" then
            for match in string.gmatch(obj.Name, uuidPattern) do
                MacroGuidHelper._guidMap[match] = { path = obj:GetFullName() .. " (Name)", source = obj }
            end
        end
        if obj:IsA("ModuleScript") then
            local ok, src = pcall(function() return obj.Source end)
            if ok and type(src) == "string" then
                for match in string.gmatch(src, uuidPattern) do
                    MacroGuidHelper._guidMap[match] = { path = obj:GetFullName() .. " (ModuleScript source)", source = obj }
                end
            end
        end
    end
end

local function buildGuidMap()
    MacroGuidHelper._guidMap = {}
    local roots = {
        ReplicatedStorage,
        workspace,
        workspace:FindFirstChild("Packages") or workspace,
        LocalPlayer,
        LocalPlayer:FindFirstChild("Backpack") or LocalPlayer,
    }
    for _, r in ipairs(roots) do
        if r then pcall(scanRootForGuids, r) end
    end
    pcall(function()
        local rep = ReplicatedStorage:FindFirstChild("Replicated")
        if rep then scanRootForGuids(rep) end
    end)
    pcall(function()
        local packages = ReplicatedStorage:FindFirstChild("Packages")
        if packages then scanRootForGuids(packages) end
    end)
    return MacroGuidHelper._guidMap
end

local function findEquippedTowers()
    MacroGuidHelper._equipped = {}
    local containers = {}
    table.insert(containers, LocalPlayer:FindFirstChild("Backpack"))
    table.insert(containers, LocalPlayer.Character)
    table.insert(containers, workspace:FindFirstChild("Units"))
    table.insert(containers, workspace:FindFirstChild(LocalPlayer.Name))
    table.insert(containers, workspace:FindFirstChild("PlayerUnits"))
    table.insert(containers, workspace)

    for _, container in ipairs(containers) do
        if container then
            for _, obj in ipairs(safeDescendants(container)) do
                if obj.GetAttributes then
                    local ok, attrs = pcall(function() return obj:GetAttributes() end)
                    if ok and type(attrs) == "table" then
                        for k,v in pairs(attrs) do
                            if type(v) == "string" then
                                for match in string.gmatch(v, uuidPattern) do
                                    table.insert(MacroGuidHelper._equipped, { name = obj.Name or "Unnamed", guid = match, instance = obj, source = container:GetFullName() })
                                end
                            end
                        end
                    end
                end
                if obj:IsA("StringValue") and type(obj.Value) == "string" then
                    for match in string.gmatch(obj.Value, uuidPattern) do
                        table.insert(MacroGuidHelper._equipped, { name = obj.Name or "Unnamed", guid = match, instance = obj, source = container:GetFullName() })
                    end
                end
                if obj:IsA("ModuleScript") then
                    local ok, src = pcall(function() return obj.Source end)
                    if ok and type(src) == "string" then
                        for match in string.gmatch(src, uuidPattern) do
                            table.insert(MacroGuidHelper._equipped, { name = obj.Name or "Module", guid = match, instance = obj, source = container:GetFullName() })
                        end
                    end
                end
            end
        end
    end

    local seen = {}
    local dedup = {}
    for _, e in ipairs(MacroGuidHelper._equipped) do
        if not seen[e.guid] then
            seen[e.guid] = true
            table.insert(dedup, e)
        end
    end
    MacroGuidHelper._equipped = dedup
    return MacroGuidHelper._equipped
end

local function findSpawnRemote()
    local ok, rep = pcall(function() return ReplicatedStorage:FindFirstChild("Replicated") end)
    local repRoot = rep or ReplicatedStorage
    local function tryPath(root)
        if not root then return nil end
        local current = root
        local names = {"Packages", "Knit", "Services", "AttackUnitService", "RF", "Spawn"}
        for _, n in ipairs(names) do
            current = current:FindFirstChild(n)
            if not current then return nil end
        end
        return current
    end
    local remote = tryPath(repRoot)
    if remote then
        MacroGuidHelper._spawnRemote = remote
        return remote
    end
    for _, obj in ipairs(safeDescendants(ReplicatedStorage)) do
        if (obj:IsA("RemoteFunction") or obj:IsA("RemoteEvent")) and obj.Name:lower():find("spawn") then
            MacroGuidHelper._spawnRemote = obj
            return obj
        end
    end
    return nil
end

local function tryWrapSpawnInvoke()
    local spawnRemote = MacroGuidHelper._spawnRemote
    if not spawnRemote then return false end
    if spawnRemote:IsA("RemoteFunction") then
        if not MacroGuidHelper._invokeWrapper then
            MacroGuidHelper._invokeWrapper = function(...)
                local args = {...}
                for i, a in ipairs(args) do
                    if type(a) == "string" and string.match(a, uuidPattern) then
                        MacroGuidHelper._guidMap[a] = MacroGuidHelper._guidMap[a] or { path = "Captured from Spawn InvokeServer", source = spawnRemote }
                        print("[MacroGuidHelper] Captured GUID from Spawn args:", a)
                    end
                end
                local ok, res = pcall(function() return spawnRemote:InvokeServer(unpack(args)) end)
                if not ok then warn("[MacroGuidHelper] Spawn InvokeServer wrapper error:", res) end
                return res
            end
            return true
        end
    elseif spawnRemote:IsA("RemoteEvent") then
        if not MacroGuidHelper._eventConn then
            local conn = spawnRemote.OnClientEvent:Connect(function(...)
                local args = {...}
                for i, a in ipairs(args) do
                    if type(a) == "string" and string.match(a, uuidPattern) then
                        MacroGuidHelper._guidMap[a] = MacroGuidHelper._guidMap[a] or { path = "Captured from Spawn OnClientEvent", source = spawnRemote }
                        print("[MacroGuidHelper] Captured GUID from Spawn event:", a)
                    end
                end
            end)
            MacroGuidHelper._eventConn = conn
            return true
        end
    end
    return false
end

local function placeTower(guid, cframe)
    if type(guid) ~= "string" then return false, "guid must be string" end
    if typeof(cframe) ~= "CFrame" then return false, "cframe must be CFrame" end
    if not MacroGuidHelper._spawnRemote then findSpawnRemote() end
    if not MacroGuidHelper._spawnRemote then return false, "Spawn remote not found" end
    local args = { guid, cframe }
    local ok, res = pcall(function()
        if MacroGuidHelper._invokeWrapper then
            return MacroGuidHelper._invokeWrapper(unpack(args))
        else
            return MacroGuidHelper._spawnRemote:InvokeServer(unpack(args))
        end
    end)
    if not ok then return false, res end
    return true, res
end

MacroGuidHelper.GetGuidMap = function() return MacroGuidHelper._guidMap end
MacroGuidHelper.RebuildGuidMap = function() return buildGuidMap() end
MacroGuidHelper.FindEquipped = function() return findEquippedTowers() end
MacroGuidHelper.FindSpawnRemote = function() return findSpawnRemote() end
MacroGuidHelper.TryWrapSpawn = function() return tryWrapSpawnInvoke() end
MacroGuidHelper.PlaceTower = function(guid, cframe) return placeTower(guid, cframe) end

buildGuidMap()
findEquippedTowers()
findSpawnRemote()
tryWrapSpawnInvoke()

spawn(function()
    while true do
        task.wait(6)
        buildGuidMap()
        findEquippedTowers()
        if not MacroGuidHelper._spawnRemote then
            findSpawnRemote()
            tryWrapSpawnInvoke()
        end
    end
end)

_G.MacroGuidHelper = MacroGuidHelper

-- ======= TowerPlacementWatcher (watches workspace.Towers) =======
local TowerPlacementWatcher = {}
TowerPlacementWatcher.history = {}
TowerPlacementWatcher.indexByUUID = {}
TowerPlacementWatcher.indexByName = {}
TowerPlacementWatcher.maxHistory = 200
TowerPlacementWatcher.towersFolder = workspace:FindFirstChild("Towers")

local function safeGet(obj, fn)
    local ok, res = pcall(fn)
    if ok then return res end
    return nil
end

local function recordPlacement(instance)
    if not instance or not instance.Parent then return end
    local config = instance:FindFirstChild("Config")
    if not config then return end

    local towerNameVal = config:FindFirstChild("TowerName")
    local unitUUIDVal = config:FindFirstChild("UnitUUID")

    local towerName = nil
    local unitUUID = nil

    if towerNameVal and towerNameVal:IsA("StringValue") then
        towerName = towerNameVal.Value
    else
        towerName = safeGet(config, function() return config:FindFirstChild("TowerName") and config:FindFirstChild("TowerName").Value end)
    end

    if unitUUIDVal and unitUUIDVal:IsA("StringValue") then
        unitUUID = unitUUIDVal.Value
    else
        unitUUID = safeGet(config, function() return config:FindFirstChild("UnitUUID") and config:FindFirstChild("UnitUUID").Value end)
    end

    local basePart = instance:FindFirstChild("TowerBase")
    local cframe = nil
    if basePart and basePart:IsA("BasePart") then
        cframe = basePart.CFrame
    else
        local primary = safeGet(instance, function() return instance.PrimaryPart end)
        if primary and primary:IsA("BasePart") then
            cframe = primary.CFrame
        else
            for _, d in ipairs(instance:GetDescendants()) do
                if d:IsA("BasePart") then
                    cframe = d.CFrame
                    break
                end
            end
        end
    end

    local rec = {
        name = towerName or "Unknown",
        uuid = unitUUID or "Unknown",
        cframe = cframe,
        instance = instance,
        timestamp = tick()
    }

    table.insert(TowerPlacementWatcher.history, rec)
    if #TowerPlacementWatcher.history > TowerPlacementWatcher.maxHistory then
        table.remove(TowerPlacementWatcher.history, 1)
    end

    if rec.uuid and rec.uuid ~= "Unknown" then
        TowerPlacementWatcher.indexByUUID[rec.uuid] = rec
    end

    if rec.name then
        TowerPlacementWatcher.indexByName[rec.name] = TowerPlacementWatcher.indexByName[rec.name] or {}
        table.insert(TowerPlacementWatcher.indexByName[rec.name], rec)
        if #TowerPlacementWatcher.indexByName[rec.name] > 10 then
            table.remove(TowerPlacementWatcher.indexByName[rec.name], 1)
        end
    end

    if _G and _G.MacroGuidHelper and rec.uuid and rec.uuid ~= "Unknown" then
        _G.MacroGuidHelper._guidMap = _G.MacroGuidHelper._guidMap or {}
        if not _G.MacroGuidHelper._guidMap[rec.uuid] then
            _G.MacroGuidHelper._guidMap[rec.uuid] = { path = instance:GetFullName() .. " (captured from workspace.Towers)", source = instance }
        end
    end

    return rec
end

local function initialScan()
    TowerPlacementWatcher.towersFolder = workspace:FindFirstChild("Towers")
    if not TowerPlacementWatcher.towersFolder then return end
    for _, child in ipairs(TowerPlacementWatcher.towersFolder:GetChildren()) do
        if child:IsA("Model") or child:IsA("Folder") then
            pcall(function() recordPlacement(child) end)
        end
    end
end

local childAddedConn = nil
local function startWatching()
    TowerPlacementWatcher.towersFolder = workspace:FindFirstChild("Towers")
    if not TowerPlacementWatcher.towersFolder then
        TowerPlacementWatcher.towersFolder = workspace:WaitForChild("Towers", 5)
        if not TowerPlacementWatcher.towersFolder then return end
    end

    initialScan()

    if childAddedConn then childAddedConn:Disconnect(); childAddedConn = nil end

    childAddedConn = TowerPlacementWatcher.towersFolder.ChildAdded:Connect(function(child)
        task.delay(0.05, function()
            local ok, rec = pcall(function() return recordPlacement(child) end)
            if ok and rec then
                pcall(function()
                    MacroEvent:Fire({
                        EventType = "PlacementCaptured",
                        name = rec.name,
                        uuid = rec.uuid,
                        cframe = rec.cframe,
                        instance = rec.instance,
                        timestamp = rec.timestamp
                    })
                end)
            end
        end)
    end)
end

function TowerPlacementWatcher.GetLatest()
    return TowerPlacementWatcher.history[#TowerPlacementWatcher.history]
end

function TowerPlacementWatcher.GetHistory(n)
    n = n or TowerPlacementWatcher.maxHistory
    local hist = TowerPlacementWatcher.history
    if n >= #hist then return hist end
    local out = {}
    for i = math.max(1, #hist - n + 1), #hist do
        table.insert(out, hist[i])
    end
    return out
end

function TowerPlacementWatcher.GetByUUID(uuid)
    return TowerPlacementWatcher.indexByUUID[uuid]
end

function TowerPlacementWatcher.GetByName(name)
    return TowerPlacementWatcher.indexByName[name] or {}
end

function TowerPlacementWatcher.WaitForNextPlacement(timeout)
    local start = tick()
    local lastCount = #TowerPlacementWatcher.history
    while true do
        if #TowerPlacementWatcher.history > lastCount then
            return TowerPlacementWatcher.history[#TowerPlacementWatcher.history]
        end
        if timeout and tick() - start >= timeout then
            return nil, "timeout"
        end
        task.wait(0.03)
    end
end

function TowerPlacementWatcher.ResolveNameToUUID(name)
    local byName = TowerPlacementWatcher.GetByName(name)
    if byName and #byName > 0 then
        return byName[#byName].uuid
    end
    if _G and _G.MacroGuidHelper then
        for guid, info in pairs(_G.MacroGuidHelper._guidMap or {}) do
            if info.path and tostring(info.path):lower():find(name:lower()) then
                return guid
            end
        end
    end
    return nil
end

function TowerPlacementWatcher.GetCFrameForUUID(uuid)
    local rec = TowerPlacementWatcher.GetByUUID(uuid)
    if rec and rec.cframe then return rec.cframe end
    return nil
end

startWatching()
_G.TowerPlacementWatcher = TowerPlacementWatcher

-- ======= Convenience: auto-attach placement data to macro events (optional) =======
-- When recording, if a placement is detected shortly after a recorded input, append placement info to the last recorded event.
local function tryAttachPlacementToRecording()
    if not isRecording then return end
    -- Wait briefly for placement to appear
    local rec, err = TowerPlacementWatcher.WaitForNextPlacement(2)
    if rec then
        -- attach to last recorded event if exists
        if currentRecording and #currentRecording > 0 then
            local last = currentRecording[#currentRecording]
            last.Placement = { name = rec.name, uuid = rec.uuid, cframe = rec.cframe }
        end
    end
end

-- Example: connect MacroEvent listener to detect placement captures and attach if recording
MacroEvent.Event:Connect(function(data)
    if data.EventType == "PlacementCaptured" then
        -- placement captured; attach if recording
        if isRecording and currentRecording and #currentRecording > 0 then
            local last = currentRecording[#currentRecording]
            last.Placement = { name = data.name, uuid = data.uuid, cframe = data.cframe }
        end
    end
end)

-- ======= Example playback listener (user should implement actual actions) =======
-- This sample shows how to react to MacroEvent during playback.
-- It looks for events that include Placement info and calls PlaceTower.
MacroEvent.Event:Connect(function(ev)
    -- ev may be a playback event or a placement-captured event
    if ev.EventType == "PlacementCaptured" then
        -- handled elsewhere
        return
    end

    -- If playback event includes Placement data, attempt to place tower
    if ev and ev.Type and ev.Type == "Began" and ev.KeyCode and tostring(ev.KeyCode) == "Enum.KeyCode.ButtonR2" then
        -- example: ignore; placeholder for custom logic
    end
    -- If the macro event contains a Placement payload (when recorded), handle it
    if ev and ev.Placement then
        local p = ev.Placement
        if p.uuid and p.cframe then
            local ok, res = MacroGuidHelper.PlaceTower(p.uuid, p.cframe)
            if not ok and debugX then
                warn("PlaceTower failed:", res)
            end
        end
    end
end)

-- ======= Finalize =======
Rayfield:LoadConfiguration()

-- Print summary for debugging
if debugX then
    print("[MacroSystem] Initialized.")
    print("[MacroSystem] Macros available:", #MacroNames)
    print("[MacroSystem] MacroEvent located at:", MacroEvent and MacroEvent:GetFullName() or "nil")
    if MacroGuidHelper._spawnRemote then
        print("[MacroGuidHelper] Spawn remote found at:", MacroGuidHelper._spawnRemote:GetFullName())
    else
        print("[MacroGuidHelper] Spawn remote not found yet.")
    end
end
