-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library
local success, Rayfield = pcall(function()
    return loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
end)
if not success or not Rayfield then
    warn("Failed to load Rayfield. Ensure HTTP requests are allowed and the URL is reachable.")
    return
end
_G.RayfieldInstance = Rayfield

-- Safe window creation helper (waits for Rayfield to be ready)
local function safeCreateWindow(createArgs, timeout)
    timeout = timeout or 6
    local start = tick()
    while tick() - start < timeout do
        if Rayfield and type(Rayfield.CreateWindow) == "function" then
            local ok, win = pcall(function() return Rayfield:CreateWindow(createArgs) end)
            if ok and win then
                return win
            end
        end
        task.wait(0.12)
    end
    return nil
end

local Window = safeCreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
}, 8)

if not Window then
    warn("Rayfield failed to initialize or CreateWindow timed out. UI will not be created.")
    return
end

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867"
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)

-- Services
local Players = game:GetService("Players")
local Rep = game:GetService("ReplicatedStorage")

-- Utility functions
local function readTextOrValue(inst)
    if not inst then return nil end
    if inst:IsA("TextLabel") or inst:IsA("TextBox") or inst:IsA("TextButton") then
        if type(inst.Text) == "string" and inst.Text ~= "" then return inst.Text end
    end
    if inst:IsA("ValueBase") and inst.Value ~= nil then return tostring(inst.Value) end
    local ok, txt = pcall(function() return inst.Text end)
    if ok and type(txt) == "string" and txt ~= "" then return txt end
    local ok2, val = pcall(function() return inst.Value end)
    if ok2 and val ~= nil then return tostring(val) end
    for _, c in ipairs(inst:GetChildren()) do
        if c:IsA("TextLabel") or c:IsA("TextBox") or c:IsA("TextButton") then
            if type(c.Text) == "string" and c.Text ~= "" then return c.Text end
        end
        if c:IsA("ValueBase") and c.Value ~= nil then return tostring(c.Value) end
    end
    for _, d in ipairs(inst:GetDescendants()) do
        if d:IsA("TextLabel") or d:IsA("TextBox") or d:IsA("TextButton") then
            if type(d.Text) == "string" and d.Text ~= "" then return d.Text end
        end
        if d:IsA("ValueBase") and d.Value ~= nil then return tostring(d.Value) end
    end
    return nil
end

local function parsePriceToNumber(priceStr)
    if not priceStr then return nil end
    local cleaned = tostring(priceStr):gsub("[^%d%-]", "")
    local n = tonumber(cleaned)
    return n or nil
end

local function getPlayerCash()
    local pl = Players.LocalPlayer
    if not pl then return 0 end
    local leaderstats = pl:FindFirstChild("leaderstats")
    if not leaderstats then return 0 end
    local cash = leaderstats:FindFirstChild("Cash")
    if not cash then return 0 end
    return tonumber(cash.Value) or 0
end

local function findFieldValue(container, nameCandidates)
    if not container then return nil end
    local lowerCandidates = {}
    for _, n in ipairs(nameCandidates) do lowerCandidates[#lowerCandidates+1] = string.lower(n) end

    for _, child in ipairs(container:GetChildren()) do
        local lname = string.lower(child.Name or "")
        for _, cand in ipairs(lowerCandidates) do
            if lname == cand or lname:find(cand) then
                local v = readTextOrValue(child)
                if v and v ~= "" then return v end
            end
        end
    end

    for _, desc in ipairs(container:GetDescendants()) do
        local lname = string.lower(desc.Name or "")
        for _, cand in ipairs(lowerCandidates) do
            if lname == cand or lname:find(cand) then
                local v = readTextOrValue(desc)
                if v and v ~= "" then return v end
            end
        end
    end

    for _, child in ipairs(container:GetChildren()) do
        local v = readTextOrValue(child)
        if v and v ~= "" then return v end
    end

    for _, desc in ipairs(container:GetDescendants()) do
        local v = readTextOrValue(desc)
        if v and v ~= "" then return v end
    end

    return nil
end

local function getAllSpawnedEggsInfo()
    local results = {}
    for _, child in pairs(workspace:GetChildren()) do
        if child and child:FindFirstChild("Eggtag") then
            local tag = child:FindFirstChild("Eggtag")
            if tag and tag:FindFirstChild("Container") then
                local container = tag.Container
                local priceStr = findFieldValue(container, {"Price", "price", "Cost", "cost", "Amount"}) or "N/A"
                local priceNum = parsePriceToNumber(priceStr) or 0
                local rarity = findFieldValue(container, {"Rarity", "rarity", "Tier", "tier"}) or "N/A"
                local variety = findFieldValue(container, {"Variety", "variety", "Type", "type", "Mutation", "mutation"}) or "N/A"
                local eggName = tostring(child.Name or "Unknown")
                table.insert(results, {
                    Name = eggName,
                    Price = priceStr,
                    PriceNum = priceNum,
                    Rarity = rarity,
                    Variety = variety,
                    Container = container
                })
            end
        end
    end
    return results
end

-- Rayfield UI: Main tab (renamed from Egg Status)
local MainTab = Window:CreateTab("Main", 4483362458)
local StatusSection = MainTab:CreateSection("Spawned Egg Status")
local StatusParagraph = MainTab:CreateParagraph({Title = "Egg Status", Content = "Searching for spawned egg..."})

-- Filters and controls
local FilterSection = MainTab:CreateSection("Filters")
local RARITY_OPTIONS = {"Basic", "Rare", "Epic", "Legendary", "Mythic", "Secret"}
local VARIETY_OPTIONS = {"Normal", "Golden", "Diamond", "Glitch", "Galaxy", "????"}

local selectedRarities = {}
local selectedVarieties = {}
for _, v in ipairs(RARITY_OPTIONS) do selectedRarities[string.lower(v)] = true end
for _, v in ipairs(VARIETY_OPTIONS) do selectedVarieties[string.lower(v)] = true end

local function copyList(tbl)
    local out = {}
    for i, v in ipairs(tbl) do out[i] = v end
    return out
end

-- Speed control defaults (driven by slider)
local spawnInterval = 1.0
local requestCooldown = 0.22
local attemptDelay = 1.0
local pollInterval = 0.18
local purchaseRetryDelay = 0.6

local function applySpeed(s)
    spawnInterval = tonumber(s) or 1.0
    requestCooldown = math.max(0.12, spawnInterval * 0.22)
    attemptDelay = math.max(0.12, spawnInterval)
    pollInterval = math.max(0.08, spawnInterval * 0.18)
    purchaseRetryDelay = math.max(0.4, spawnInterval * 0.6)
end
applySpeed(spawnInterval)

-- Remote helper (defined before Misc tab)
local function getRemoteSafe(name)
    local ok, rem = pcall(function()
        return Rep:WaitForChild("Modules"):WaitForChild("Internals"):WaitForChild("Skeleton"):WaitForChild("Conduit"):WaitForChild("Instances"):WaitForChild(name)
    end)
    if ok then return rem end
    return nil
end

-- Create dropdowns and slider
if not (MainTab and type(MainTab.CreateDropdown) == "function") then
    warn("MainTab API not ready; UI elements may not be created.")
else
    local RaritiesDropdown = MainTab:CreateDropdown({
        Name = "Rarities",
        Options = RARITY_OPTIONS,
        CurrentOption = copyList(RARITY_OPTIONS),
        MultipleOptions = true,
        Flag = "RaritiesFilter",
        Callback = function(selection)
            selectedRarities = {}
            if type(selection) == "table" then
                for _, s in ipairs(selection) do
                    if type(s) == "string" then selectedRarities[string.lower(s)] = true end
                end
            elseif type(selection) == "string" then
                selectedRarities[string.lower(selection)] = true
            end
        end,
    })

    pcall(function()
        local init = (RaritiesDropdown and RaritiesDropdown.CurrentOption) or copyList(RARITY_OPTIONS)
        if type(init) == "table" then
            selectedRarities = {}
            for _, s in ipairs(init) do if type(s) == "string" then selectedRarities[string.lower(s)] = true end end
        end
    end)

    local VarietiesDropdown = MainTab:CreateDropdown({
        Name = "Varieties",
        Options = VARIETY_OPTIONS,
        CurrentOption = copyList(VARIETY_OPTIONS),
        MultipleOptions = true,
        Flag = "VarietiesFilter",
        Callback = function(selection)
            selectedVarieties = {}
            if type(selection) == "table" then
                for _, s in ipairs(selection) do
                    if type(s) == "string" then selectedVarieties[string.lower(s)] = true end
                end
            elseif type(selection) == "string" then
                selectedVarieties[string.lower(selection)] = true
            end
        end,
    })

    pcall(function()
        local init = (VarietiesDropdown and VarietiesDropdown.CurrentOption) or copyList(VARIETY_OPTIONS)
        if type(init) == "table" then
            selectedVarieties = {}
            for _, s in ipairs(init) do if type(s) == "string" then selectedVarieties[string.lower(s)] = true end end
        end
    end)

    -- Allowed spawn interval values
    local ALLOWED_SPAWN_VALUES = {0.5, 0.6, 0.7, 0.8, 0.9, 1.0}
    local function snapToAllowed(val)
        val = tonumber(val) or 1.0
        local best = ALLOWED_SPAWN_VALUES[1]
        local bestDiff = math.abs(val - best)
        for _, v in ipairs(ALLOWED_SPAWN_VALUES) do
            local d = math.abs(val - v)
            if d < bestDiff then
                best = v
                bestDiff = d
            end
        end
        return best
    end

    local SpeedSlider = MainTab:CreateSlider({
        Name = "Spawn Interval (seconds)",
        Range = {0.5, 1.0},
        Increment = 0.1,
        Suffix = "s",
        CurrentValue = spawnInterval,
        Flag = "SpawnInterval",
        Callback = function(value)
            -- snap to allowed discrete values
            local snapped = snapToAllowed(value)
            applySpeed(snapped)
            -- ensure UI reflects snapped value if API supports setting it back
            pcall(function()
                if SpeedSlider and SpeedSlider.SetValue then
                    SpeedSlider:SetValue(snapped)
                end
            end)
        end,
    })

    -- Skip-if-too-expensive toggle
    local skipIfTooExpensive = false
    MainTab:CreateToggle({
        Name = "Skip if too expensive",
        CurrentValue = false,
        Flag = "SkipIfTooExpensive",
        Callback = function(val)
            skipIfTooExpensive = val and true or false
        end,
    })
end

-- Status paragraph updater
spawn(function()
    while true do
        local ok, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
        if ok and eggs and #eggs > 0 then
            local lines = {}
            for i, e in ipairs(eggs) do
                lines[#lines+1] = string.format("%d) Name: %s | Price: %s | Rarity: %s | Variety: %s", i, tostring(e.Name), tostring(e.Price), tostring(e.Rarity), tostring(e.Variety))
            end
            pcall(function() StatusParagraph:Set({Title = "Egg Status", Content = table.concat(lines, "\n")}) end)
        else
            pcall(function() StatusParagraph:Set({Title = "Egg Status", Content = "No egg detected."}) end)
        end
        task.wait(math.max(0.5, pollInterval))
    end
end)

-- Remotes used by spawn/buy logic
local requestEggRemote = getRemoteSafe("_requestEgg")
local purchaseEggRemote = getRemoteSafe("_purchaseEgg")

-- Helper to fire the special confirmed-skip for Mythic eggs
local function fireSkipMythicRemote()
    -- This uses the same _requestEgg remote but with confirmedSkip = true in the data payload
    if not requestEggRemote then
        requestEggRemote = getRemoteSafe("_requestEgg")
        if not requestEggRemote then return false end
    end
    local ok = pcall(function()
        local args = {
            {
                __raw = true,
                data = {
                    confirmedSkip = true
                }
            }
        }
        requestEggRemote:FireServer(unpack(args))
    end)
    return ok
end

-- waitUntilNoEgg
local function waitUntilNoEgg(timeout)
    local start = tick()
    while (tick() - start) < (timeout or 8) do
        local ok, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
        if ok and (not eggs or #eggs == 0) then return true end
        task.wait(pollInterval)
    end
    return false
end

-- attemptPurchaseFromInfo
local function attemptPurchaseFromInfo(eggInfo, waitForDisappear)
    if not eggInfo or not purchaseEggRemote then return false end
    local namePart = tostring(eggInfo.Name or "Unknown"):gsub("%s+", "_"):gsub("[^%w_]", "_")
    local rarityPart = tostring(eggInfo.Rarity or "Basic")
    local varietyPart = tostring(eggInfo.Variety or "Glitch")
    local idString = "entity_" .. namePart .. "_egg"

    local okFire = pcall(function()
        local args = {
            {
                __raw = true,
                data = {
                    id = idString,
                    rarity = rarityPart,
                    variety = varietyPart
                }
            }
        }
        purchaseEggRemote:FireServer(unpack(args))
    end)
    if not okFire then return false end

    if not waitForDisappear then return true end

    local start = tick()
    while (tick() - start) < 5 do
        local ok, eggs = pcall(function() return getAllSpawnedEggsInfo() end)
        if ok then
            if not eggs or #eggs == 0 then return true end
            if tostring(eggs[1].Name or "") ~= tostring(eggInfo.Name or "") then return true end
        end
        task.wait(pollInterval)
    end
    return false
end

local function isEggAllowed(eggInfo)
    if not eggInfo then return false end
    local r = tostring(eggInfo.Rarity or ""):gsub("^%s*(.-)%s*$", "%1")
    local v = tostring(eggInfo.Variety or ""):gsub("^%s*(.-)%s*$", "%1")
    local rl = string.lower(r)
    local vl = string.lower(v)
    if next(selectedRarities) == nil or next(selectedVarieties) == nil then return false end
    return selectedRarities[rl] == true and selectedVarieties[vl] == true
end

-- Replacement logic (controlled)
local replacing = false
local lastRequestTime = 0

-- New toggle state for skipping mythic eggs (default false)
local skipMythic = false

local function aggressiveReplaceUntilAllowed(currentEgg)
    replacing = true
    local startName = tostring(currentEgg.Name or "")
    local SAFETY_MAX_ATTEMPTS = math.max(6, math.floor(30 * (1.0 / spawnInterval)))
    for attempt = 1, SAFETY_MAX_ATTEMPTS do
        if tick() - lastRequestTime >= requestCooldown then
            if requestEggRemote then
                pcall(function()
                    local args = {
                        {
                            __raw = true,
                            data = {}
                        }
                    }
                    requestEggRemote:FireServer(unpack(args))
                end)
            end
            lastRequestTime = tick()
        end

        task.wait(attemptDelay)

        local ok, eggsAfter = pcall(function() return getAllSpawnedEggsInfo() end)
        if ok and eggsAfter and #eggsAfter > 0 then
            local newEgg = eggsAfter[1]
            local newName = tostring(newEgg.Name or "")
            local newRarity = tostring(newEgg.Rarity or ""):gsub("^%s*(.-)%s*$", "%1")
            local newRarityLower = string.lower(newRarity)
            -- If new egg is Secret, never skip
            if newRarityLower == "secret" then
                if isEggAllowed(newEgg) then
                    replacing = false
                    return newEgg
                else
                    startName = newName
                end
            else
                -- If it's Mythic and skipMythic is enabled, fire the confirmed-skip remote and continue
                if newRarityLower == "mythic" and skipMythic then
                    pcall(function()
                        fireSkipMythicRemote()
                    end)
                    -- wait a short moment for the server to process
                    task.wait(math.max(0.12, pollInterval))
                    -- continue to next attempt without returning
                    startName = newName
                else
                    if newName ~= startName then
                        if isEggAllowed(newEgg) then
                            replacing = false
                            return newEgg
                        else
                            startName = newName
                        end
                    end
                end
            end
        else
            task.wait(math.min(0.25, attemptDelay))
        end
    end
    replacing = false
    return nil
end

-- Core auto spawn/buy loop (spawnInterval controls pace)
local autoEnabled = false
local autoThread = nil

local function autoSpawnBuyLoop()
    while autoEnabled do
        local ok, eggsNow = pcall(function() return getAllSpawnedEggsInfo() end)
        if not ok then eggsNow = {} end
        local current = (eggsNow and #eggsNow > 0) and eggsNow[1] or nil

        if current then
            local cost = tonumber(current.PriceNum) or 0
            local cash = getPlayerCash()
            local rarity = tostring(current.Rarity or ""):gsub("^%s*(.-)%s*$", "%1")
            local rarityLower = string.lower(rarity)

            -- If current is Secret, never skip or auto-skip
            if rarityLower == "secret" then
                -- treat as normal egg (no skipping)
            else
                -- If current is Mythic and skipMythic is enabled, attempt to skip via special remote
                if rarityLower == "mythic" and skipMythic then
                    -- Fire the confirmed-skip remote and then wait for next spawn
                    pcall(function()
                        fireSkipMythicRemote()
                    end)
                    -- small wait to allow server to process
                    task.wait(math.max(0.12, pollInterval))
                    -- continue main loop
                    task.wait(math.min(0.25, spawnInterval))
                    -- request next egg if cooldown allows
                    if tick() - lastRequestTime >= requestCooldown and requestEggRemote then
                        pcall(function()
                            local args = {
                                {
                                    __raw = true,
                                    data = {}
                                }
                            }
                            requestEggRemote:FireServer(unpack(args))
                        end)
                        lastRequestTime = tick()
                    end
                    -- skip the rest of processing for this egg
                    task.wait(0.05)
                    continue
                end
            end

            if isEggAllowed(current) then
                if skipIfTooExpensive and cost > 0 and cash < cost then
                    if tick() - lastRequestTime >= requestCooldown and requestEggRemote then
                        pcall(function()
                            local args = {
                                {
                                    __raw = true,
                                    data = {}
                                }
                            }
                            requestEggRemote:FireServer(unpack(args))
                        end)
                        lastRequestTime = tick()
                    end
                    local waited = 0
                    while autoEnabled and waited < spawnInterval do
                        task.wait(math.min(0.12, spawnInterval))
                        waited = waited + math.min(0.12, spawnInterval)
                    end
                else
                    if cost > 0 and cash >= cost then
                        local purchased = false
                        for attempt = 1, 3 do
                            if not autoEnabled then break end
                            purchased = attemptPurchaseFromInfo(current, true)
                            if purchased then break end
                            task.wait(purchaseRetryDelay)
                        end
                        if purchased then
                            waitUntilNoEgg(10)
                            task.wait(0.25)
                        else
                            waitUntilNoEgg(12)
                            task.wait(0.25)
                        end
                    else
                        local affordTimeout = 180
                        local start = tick()
                        while autoEnabled and (tick() - start) < affordTimeout do
                            local newCash = getPlayerCash()
                            local ok2, eggsCheck = pcall(function() return getAllSpawnedEggsInfo() end)
                            if ok2 and (not eggsCheck or #eggsCheck == 0) then break end
                            if newCash >= cost then
                                local purchased = attemptPurchaseFromInfo(current, true)
                                if purchased then waitUntilNoEgg(10) end
                                break
                            end
                            task.wait(math.max(0.25, pollInterval))
                        end
                        task.wait(0.25)
                    end
                end
            else
                if skipIfTooExpensive and cost > 0 and getPlayerCash() < cost then
                    if tick() - lastRequestTime >= requestCooldown and requestEggRemote then
                        pcall(function()
                            local args = {
                                {
                                    __raw = true,
                                    data = {}
                                }
                            }
                            requestEggRemote:FireServer(unpack(args))
                        end)
                        lastRequestTime = tick()
                    end
                    local waited = 0
                    while autoEnabled and waited < spawnInterval do
                        task.wait(math.min(0.12, spawnInterval))
                        waited = waited + math.min(0.12, spawnInterval)
                    end
                else
                    if not replacing then
                        local allowedEgg = aggressiveReplaceUntilAllowed(current)
                        if allowedEgg then
                            local cost2 = tonumber(allowedEgg.PriceNum) or 0
                            local cash2 = getPlayerCash()
                            if cost2 > 0 and cash2 >= cost2 then
                                local purchased = attemptPurchaseFromInfo(allowedEgg, true)
                                if purchased then waitUntilNoEgg(10) end
                            else
                                if skipIfTooExpensive and cost2 > 0 and cash2 < cost2 then
                                    if tick() - lastRequestTime >= requestCooldown and requestEggRemote then
                                        pcall(function()
                                            local args = {
                                                {
                                                    __raw = true,
                                                    data = {}
                                                }
                                            }
                                            requestEggRemote:FireServer(unpack(args))
                                        end)
                                        lastRequestTime = tick()
                                    end
                                    task.wait(spawnInterval)
                                else
                                    local start = tick()
                                    local affordTimeout = 180
                                    while autoEnabled and (tick() - start) < affordTimeout do
                                        local newCash = getPlayerCash()
                                        local ok2, eggsCheck = pcall(function() return getAllSpawnedEggsInfo() end)
                                        if ok2 and (not eggsCheck or #eggsCheck == 0) then break end
                                        if newCash >= cost2 then
                                            local purchased = attemptPurchaseFromInfo(allowedEgg, true)
                                            if purchased then waitUntilNoEgg(10) end
                                            break
                                        end
                                        task.wait(math.max(0.25, pollInterval))
                                    end
                                end
                            end
                        else
                            task.wait(math.max(0.6, spawnInterval))
                        end
                    else
                        task.wait(math.min(0.18, spawnInterval))
                    end
                end
            end
        else
            if tick() - lastRequestTime >= requestCooldown and requestEggRemote then
                pcall(function()
                    local args = {
                        {
                            __raw = true,
                            data = {}
                        }
                    }
                    requestEggRemote:FireServer(unpack(args))
                end)
                lastRequestTime = tick()
            end

            local waited = 0
            while autoEnabled and waited < spawnInterval do
                task.wait(math.min(0.12, spawnInterval))
                waited = waited + math.min(0.12, spawnInterval)
            end
        end

        task.wait(math.max(0.05, pollInterval * 0.5))
    end
end

-- Create Auto Spawn+Buy toggle
MainTab:CreateToggle({
    Name = "Auto Spawn+Buy Eggs",
    CurrentValue = false,
    Flag = "AutoSpawnBuyEggs",
    Callback = function(val)
        autoEnabled = val
        if autoEnabled then
            if not autoThread or coroutine.status(autoThread) ~= "running" then
                autoThread = spawn(function() autoSpawnBuyLoop() end)
            end
        end
    end
})

-- Misc tab: Auto Sell and Auto Rebirth
local MiscTab = Window:CreateTab("Misc", 4483362458)
local MiscSection = MiscTab:CreateSection("Automation")

-- Remotes for misc actions (use helper defined earlier)
local collectRemote = getRemoteSafe("_collectEarnings")
local sellRemote = getRemoteSafe("_sellStack")
local rebirthRemote = getRemoteSafe("doRebirth")

-- Auto Sell
local autoSellEnabled = false
local autoSellThread = nil

local function equipBoxStack()
    local pl = Players.LocalPlayer
    if not pl then return false end

    local function findTool(container)
        if not container then return nil end
        for _, item in ipairs(container:GetChildren()) do
            if item:IsA("Tool") then
                local name = tostring(item.Name or "")
                if name:lower():find("box stack") then
                    return item
                end
            end
        end
        return nil
    end

    local backpack = pl:FindFirstChild("Backpack")
    local char = pl.Character
    local tool = findTool(backpack) or findTool(char)
    if not tool then return false end

    local ok = pcall(function()
        if tool.Parent ~= char and char then
            tool.Parent = char
        end
        if type(tool.Activate) == "function" then
            pcall(function() tool:Activate() end)
        end
    end)
    return ok
end

local function autoSellCycle()
    if collectRemote then
        pcall(function()
            local args = {
                {
                    __raw = true,
                    data = {}
                }
            }
            collectRemote:FireServer(unpack(args))
        end)
    end

    task.wait(0.25)

    local equipped = equipBoxStack()
    task.wait(0.25)

    if sellRemote and equipped then
        pcall(function()
            local args = {
                {
                    __raw = true,
                    data = {}
                }
            }
            sellRemote:FireServer(unpack(args))
        end)
    end
end

local function autoSellLoop()
    while autoSellEnabled do
        pcall(autoSellCycle)
        local waited = 0
        local interval = 30
        while autoSellEnabled and waited < interval do
            task.wait(0.5)
            waited = waited + 0.5
        end
    end
end

MiscTab:CreateToggle({
    Name = "Auto Sell",
    CurrentValue = false,
    Flag = "AutoSellToggle",
    Callback = function(val)
        autoSellEnabled = val and true or false
        if autoSellEnabled then
            if not autoSellThread or coroutine.status(autoSellThread) ~= "running" then
                autoSellThread = spawn(function() autoSellLoop() end)
            end
        end
    end,
})

-- Auto Rebirth
local autoRebirthEnabled = false
local autoRebirthThread = nil
local REBIRTH_INTERVAL = 10 * 60 -- 10 minutes

local function doRebirthOnce()
    if not rebirthRemote then
        rebirthRemote = getRemoteSafe("doRebirth")
        if not rebirthRemote then return false end
    end
    local ok = pcall(function()
        local args = {
            {
                __raw = true,
                data = {}
            }
        }
        rebirthRemote:FireServer(unpack(args))
    end)
    return ok
end

local function autoRebirthLoop()
    while autoRebirthEnabled do
        pcall(doRebirthOnce)
        local waited = 0
        while autoRebirthEnabled and waited < REBIRTH_INTERVAL do
            task.wait(1)
            waited = waited + 1
        end
    end
end

MiscTab:CreateToggle({
    Name = "Auto Rebirth",
    CurrentValue = false,
    Flag = "AutoRebirthToggle",
    Callback = function(val)
        autoRebirthEnabled = val and true or false
        if autoRebirthEnabled then
            if not autoRebirthThread or coroutine.status(autoRebirthThread) ~= "running" then
                autoRebirthThread = spawn(function() autoRebirthLoop() end)
            end
        end
    end,
})

-- New Skip Mythic toggle (never skip Secret)
MiscTab:CreateToggle({
    Name = "Skip Mythic",
    CurrentValue = false,
    Flag = "SkipMythicToggle",
    Callback = function(val)
        skipMythic = val and true or false
    end,
})

-- End of script
