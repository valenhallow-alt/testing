-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867"
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)

-- =========================
-- Egg Stats tab
-- =========================

local EggTab = Window:CreateTab("Egg Stats", 4483362458)
local EggSection = EggTab:CreateSection("Egg Information")

local ParentLabel = EggTab:CreateLabel("Parent: N/A", 4483362458, Color3.fromRGB(255,255,255), false)
local PriceLabel = EggTab:CreateLabel("Price: N/A", 4483362458, Color3.fromRGB(255,255,255), false)
local RarityLabel = EggTab:CreateLabel("Rarity: N/A", 4483362458, Color3.fromRGB(255,255,255), false)
local VarietyLabel = EggTab:CreateLabel("Variety: N/A", 4483362458, Color3.fromRGB(255,255,255), false)

-- Helper: safely read a property from a container (handles Value objects, TextLabels, StringValues, etc.)
local function readContainerField(container, fieldName)
    if not container then return nil end
    local ok, result = pcall(function()
        local obj = container:FindFirstChild(fieldName)
        if not obj then return nil end
        if obj:IsA("StringValue") or obj:IsA("IntValue") or obj:IsA("NumberValue") or obj:IsA("BoolValue") then
            return obj.Value
        end
        if obj:IsA("TextLabel") or obj:IsA("TextBox") then
            return obj.Text
        end
        if obj.Value ~= nil then
            return obj.Value
        end
        if obj.Text ~= nil then
            return obj.Text
        end
        return tostring(obj)
    end)
    if ok then return result end
    return nil
end

-- Find the current Eggtag and its parent name
local function findEggTag()
    for _, child in ipairs(workspace:GetChildren()) do
        local eggtag = child:FindFirstChild("Eggtag")
        if eggtag then
            return eggtag, child.Name
        end
    end
    for _, desc in ipairs(workspace:GetDescendants()) do
        if desc.Name == "Eggtag" then
            local parent = desc.Parent
            return desc, parent and parent.Name or nil
        end
    end
    return nil, nil
end

-- Update UI labels from a given eggtag instance
local function updateEggInfo(eggtag, parentName)
    if not eggtag then
        ParentLabel:Set("Parent: N/A")
        PriceLabel:Set("Price: N/A")
        RarityLabel:Set("Rarity: N/A")
        VarietyLabel:Set("Variety: N/A")
        return
    end

    local container = eggtag:FindFirstChild("Container") or eggtag
    local price = readContainerField(container, "Price") or "N/A"
    local rarity = readContainerField(container, "Rarity") or "N/A"
    local variety = readContainerField(container, "Variety") or "N/A"

    ParentLabel:Set("Parent: " .. (tostring(parentName) or "N/A"))
    PriceLabel:Set("Price: " .. tostring(price))
    RarityLabel:Set("Rarity: " .. tostring(rarity))
    VarietyLabel:Set("Variety: " .. tostring(variety))
end

local currentEggTag = nil
local currentParentName = nil

local function bindContainerListeners(eggtag)
    if not eggtag then return end
    local container = eggtag:FindFirstChild("Container") or eggtag
    if not container then return end

    -- Disconnect previous listeners if present
    if container._rayfield_listeners then
        for _, conn in ipairs(container._rayfield_listeners) do
            pcall(function() conn:Disconnect() end)
        end
    end
    container._rayfield_listeners = {}

    -- Listen for children changes on the container
    local added = container.ChildAdded:Connect(function() pcall(function() refreshCurrentEgg() end) end)
    local removed = container.ChildRemoved:Connect(function() pcall(function() refreshCurrentEgg() end) end)
    table.insert(container._rayfield_listeners, added)
    table.insert(container._rayfield_listeners, removed)

    -- Listen for value/text changes on relevant children
    for _, obj in ipairs(container:GetChildren()) do
        if obj:IsA("StringValue") or obj:IsA("NumberValue") or obj:IsA("IntValue") or obj:IsA("BoolValue") or obj:IsA("TextLabel") or obj:IsA("TextBox") then
            local conn = obj.Changed:Connect(function() pcall(function() refreshCurrentEgg() end) end)
            table.insert(container._rayfield_listeners, conn)
        end
    end
end

-- Note: forward declaration so bindContainerListeners can call refreshCurrentEgg safely
function refreshCurrentEgg() end

-- Refresh function that also binds listeners immediately when egg changes
function refreshCurrentEgg()
    local eggtag, parentName = findEggTag()
    if eggtag ~= currentEggTag or parentName ~= currentParentName then
        currentEggTag = eggtag
        currentParentName = parentName
        updateEggInfo(currentEggTag, currentParentName)
        -- Bind listeners to the new container immediately so manual spawns are tracked
        pcall(function() bindContainerListeners(currentEggTag) end)
    else
        updateEggInfo(currentEggTag, currentParentName)
    end
end

workspace.DescendantAdded:Connect(function(desc)
    if desc.Name == "Eggtag" then
        wait(0.05)
        pcall(refreshCurrentEgg)
    end
end)

workspace.DescendantRemoving:Connect(function(desc)
    if desc.Name == "Eggtag" then
        wait(0.05)
        pcall(function()
            refreshCurrentEgg()
            -- If an egg was removed and we no longer have an eggtag, treat it as confirmed
            local eggtag, _ = findEggTag()
            if not eggtag then
                lastPurchaseConfirmed = true
            end
        end)
    end
end)

spawn(function()
    while true do
        pcall(function()
            refreshCurrentEgg()
            -- Bind listeners to current egg tag if not already bound (extra safety)
            pcall(function() bindContainerListeners(currentEggTag) end)
        end)
        wait(1)
    end
end)

-- =========================
-- Main tab + Auto Buy toggle
-- =========================

local MainTab = Window:CreateTab("Main", 4483362458)
local MainSection = MainTab:CreateSection("Automation")

-- State used to ensure we don't request a new egg until the current one is confirmed purchased
local lastPurchaseConfirmed = true
local purchaseTimeout = 6 -- seconds to wait for confirmation after purchase attempt
local spawnTimeout = 6 -- seconds to wait for egg spawn after request
local interRemoteDelay = 0.4 -- seconds between firing request and purchase when both are fired sequentially

-- Helper: try to find the Instances folder and remotes; returns folder or nil + error
local function getInstancesFolder()
    local ok, inst = pcall(function()
        local rs = game:GetService("ReplicatedStorage")
        local modules = rs:WaitForChild("Modules", 2)
        if not modules then error("Modules not found") end
        local internals = modules:WaitForChild("Internals", 2)
        if not internals then error("Internals not found") end
        local skeleton = internals:WaitForChild("Skeleton", 2)
        if not skeleton then error("Skeleton not found") end
        local conduit = skeleton:WaitForChild("Conduit", 2)
        if not conduit then error("Conduit not found") end
        local instances = conduit:WaitForChild("Instances", 2)
        if not instances then error("Instances not found") end
        return instances
    end)
    if ok then return inst end
    return nil, inst
end

-- Fire _requestEgg remote and print exact remote object info
local function fireRequestEgg()
    local instances, err = getInstancesFolder()
    if not instances then
        return false, "Instances folder not found: " .. tostring(err)
    end
    local req = instances:FindFirstChild("_requestEgg")
    if not req then
        return false, "_requestEgg remote not found in Instances"
    end

    local okName, fullName = pcall(function() return req:GetFullName() end)
    print("[fireRequestEgg] About to call _requestEgg remote. Object tostring:", tostring(req), "FullName:", (okName and fullName) and fullName or "unknown")

    local ok, res = pcall(function()
        local args = {
            {
                __raw = true,
                data = {}
            }
        }
        if req.FireServer then
            req:FireServer(unpack(args))
        elseif req.InvokeServer then
            req:InvokeServer(unpack(args))
        else
            error("_requestEgg has no FireServer/InvokeServer")
        end
    end)
    return ok, res
end

-- Utility: encode args preview safely
local HttpService = game:GetService("HttpService")
local function argsPreview(args)
    local ok, json = pcall(function() return HttpService:JSONEncode(args) end)
    if ok then return json end
    return tostring(args)
end

-- Improved firePurchaseEgg: detects remote type, tries common arg styles, logs results and prints exact remote object info
local function firePurchaseEgg(id, rarity, variety)
    local instances, err = getInstancesFolder()
    if not instances then
        return false, "Instances folder not found: " .. tostring(err)
    end

    local pur = instances:FindFirstChild("_purchaseEgg")
    if not pur then
        return false, "_purchaseEgg remote not found in Instances"
    end

    local args = {
        {
            __raw = true,
            data = {
                id = tostring(id or ""),
                rarity = tostring(rarity or ""),
                variety = tostring(variety or "")
            }
        }
    }

    local okName, fullName = pcall(function() return pur:GetFullName() end)
    print("[firePurchaseEgg] About to call _purchaseEgg remote. Object tostring:", tostring(pur), "FullName:", (okName and fullName) and fullName or "unknown")
    print("[firePurchaseEgg] Args preview:", argsPreview(args))

    -- Try FireServer(unpack(args)) first if available
    if pur.FireServer then
        local ok, res = pcall(function() pur:FireServer(unpack(args)) end)
        if ok then
            print("[firePurchaseEgg] Called FireServer(unpack(args)) successfully.")
            return true, "FireServer(unpack(args)) succeeded"
        else
            print("[firePurchaseEgg] FireServer(unpack(args)) failed:", tostring(res))
            local ok2, res2 = pcall(function() pur:FireServer(args) end)
            if ok2 then
                print("[firePurchaseEgg] Called FireServer(args) successfully (table as single arg).")
                return true, "FireServer(args) succeeded"
            else
                print("[firePurchaseEgg] FireServer(args) also failed:", tostring(res2))
            end
        end
    end

    -- Try InvokeServer variants if available
    if pur.InvokeServer then
        local ok, res = pcall(function() return pur:InvokeServer(unpack(args)) end)
        if ok then
            print("[firePurchaseEgg] Called InvokeServer(unpack(args)) successfully. Return:", tostring(res))
            return true, "InvokeServer(unpack(args)) succeeded"
        else
            print("[firePurchaseEgg] InvokeServer(unpack(args)) failed:", tostring(res))
            local ok2, res2 = pcall(function() return pur:InvokeServer(args) end)
            if ok2 then
                print("[firePurchaseEgg] Called InvokeServer(args) successfully. Return:", tostring(res2))
                return true, "InvokeServer(args) succeeded"
            else
                print("[firePurchaseEgg] InvokeServer(args) also failed:", tostring(res2))
            end
        end
    end

    return false, "All call attempts failed for remote: " .. ((okName and fullName) and fullName or tostring(pur))
end

-- Wait for egg removal (confirmation of purchase) up to timeout seconds
local function waitForEggRemoval(timeout)
    local start = tick()
    while tick() - start < (timeout or purchaseTimeout) do
        local eggtag, _ = findEggTag()
        if not eggtag then
            return true
        end
        wait(0.15)
    end
    return false
end

-- Wait for egg spawn (presence of Eggtag) up to timeout seconds
local function waitForEggSpawn(timeout)
    local start = tick()
    while tick() - start < (timeout or spawnTimeout) do
        local eggtag, parentName = findEggTag()
        if eggtag then
            return eggtag, parentName
        end
        wait(0.15)
    end
    return nil, nil
end

-- Try to detect explicit entity id inside the egg container (if the game exposes it)
local function detectIdFromContainer(container)
    if not container then return nil end
    local candidates = {"Id","id","EntityId","entityId","Identifier","identifier","entity_id","Entity_ID"}
    for _, name in ipairs(candidates) do
        local v = readContainerField(container, name)
        if v and tostring(v) ~= "" then
            return tostring(v)
        end
    end
    -- Try nested children
    for _, child in ipairs(container:GetChildren()) do
        if child:IsA("ModuleScript") or child:IsA("StringValue") or child:IsA("Folder") then
            local v = readContainerField(child, "id") or readContainerField(child, "Id")
            if v and tostring(v) ~= "" then
                return tostring(v)
            end
        end
    end
    return nil
end

-- Build id from parent name as fallback, preserving capitalization pattern like "entity_Nami_egg"
local function buildEntityIdFromParent(parentName)
    if not parentName then return nil end

    -- Explicit mapping for known exceptions (add entries as you discover them)
    local mapping = {
        -- ["Nami Entity"] = "entity_Nami_egg", -- add mappings here if needed
    }
    if mapping[parentName] then
        return mapping[parentName]
    end

    local raw = tostring(parentName)
    raw = raw:gsub("[^%w%s_%-]", "") -- allow letters, numbers, spaces, underscores, hyphens
    raw = raw:gsub("%s+", "_") -- replace spaces with underscores

    local parts = {}
    for part in raw:gmatch("[^_]+") do
        local first = part:sub(1,1) or ""
        local rest = part:sub(2) or ""
        table.insert(parts, string.upper(first) .. rest)
    end
    local joined = table.concat(parts, "_")

    return "entity_" .. joined .. "_egg"
end

-- Normalize rarity/variety strings to expected casing
local function normalizeStringForRemote(s)
    if not s then return "" end
    s = tostring(s)
    s = s:gsub("^%s*(.-)%s*$", "%1")
    local lower = string.lower(s)
    local capitalized = lower:gsub("(%a)([%w_']*)", function(a,b) return string.upper(a) .. b end)
    return capitalized
end

-- Auto Buy+Spin toggle logic (improved)
_G.AutoBuySpinEggs = _G.AutoBuySpinEggs or false

local AutoBuySpinToggle = MainTab:CreateToggle({
    Name = "Auto Buy+Spin Eggs",
    CurrentValue = _G.AutoBuySpinEggs,
    Flag = "AutoBuySpinEggs",
    Callback = function(Value)
        _G.AutoBuySpinEggs = Value

        if Value then
            spawn(function()
                while _G.AutoBuySpinEggs do
                    pcall(function()
                        refreshCurrentEgg()

                        if currentEggTag then
                            local container = currentEggTag:FindFirstChild("Container") or currentEggTag
                            local explicitId = detectIdFromContainer(container)
                            local parentName = currentParentName
                            local entityId = explicitId or buildEntityIdFromParent(parentName)
                            local rawRarity = readContainerField(container, "Rarity")
                            local rawVariety = readContainerField(container, "Variety")
                            local rarity = normalizeStringForRemote(rawRarity)
                            local variety = normalizeStringForRemote(rawVariety)
                            local price = readContainerField(container, "Price")
                            local numericPrice = tonumber(tostring(price):gsub("[^%d%.%-]","")) or nil

                            print("[AutoBuySpin] Detected egg -> Parent:", tostring(parentName), "EntityId:", tostring(entityId), "Price:", tostring(price), "Rarity:", tostring(rarity), "Variety:", tostring(variety))

                            if not entityId or entityId == "" then
                                print("[AutoBuySpin] No entity id available; skipping purchase.")
                                -- No entity id means nothing to buy; treat as no pending purchase
                                lastPurchaseConfirmed = true
                            else
                                local buy = true
                                local buyThreshold = 1000 -- adjust threshold as needed
                                if numericPrice and numericPrice > buyThreshold then
                                    buy = false
                                end

                                if buy then
                                    print("[AutoBuySpin] Attempting purchase:", entityId, rarity, variety)
                                    local ok, err = firePurchaseEgg(entityId, rarity, variety)
                                    if ok then
                                        local confirmed = waitForEggRemoval(purchaseTimeout)
                                        if confirmed then
                                            lastPurchaseConfirmed = true
                                            print("[AutoBuySpin] Purchase confirmed for:", entityId)
                                        else
                                            lastPurchaseConfirmed = false
                                            print("[AutoBuySpin] Purchase not confirmed within timeout for:", entityId)
                                        end
                                    else
                                        print("[AutoBuySpin] firePurchaseEgg error:", tostring(err))
                                    end
                                else
                                    print("[AutoBuySpin] Buy conditions not met; skipping.")
                                    -- Treat skip as "no pending purchase" so we can request a new egg next loop
                                    lastPurchaseConfirmed = true
                                end
                            end
                        else
                            -- No egg present. Only request a new egg if last purchase was confirmed.
                            if lastPurchaseConfirmed then
                                print("[AutoBuySpin] No egg present. Requesting new egg via _requestEgg.")
                                local ok, err = fireRequestEgg()
                                if ok then
                                    lastPurchaseConfirmed = false
                                    -- Wait a short fixed delay between remotes as requested
                                    wait(interRemoteDelay)

                                    -- After the small delay, attempt to detect the spawned egg quickly
                                    local eggtag, parentName = waitForEggSpawn(spawnTimeout)
                                    if eggtag then
                                        print("[AutoBuySpin] Egg spawned under parent:", tostring(parentName), "-> attempting immediate purchase now.")
                                        refreshCurrentEgg()
                                        local container = eggtag:FindFirstChild("Container") or eggtag
                                        local explicitId = detectIdFromContainer(container)
                                        local entityId = explicitId or buildEntityIdFromParent(parentName)
                                        local rawRarity = readContainerField(container, "Rarity")
                                        local rawVariety = readContainerField(container, "Variety")
                                        local rarity = normalizeStringForRemote(rawRarity)
                                        local variety = normalizeStringForRemote(rawVariety)

                                        print("[AutoBuySpin] After request -> Detected egg info. EntityId:", tostring(entityId), "Rarity:", tostring(rarity), "Variety:", tostring(variety))

                                        if entityId and entityId ~= "" then
                                            local ok2, err2 = firePurchaseEgg(entityId, rarity, variety)
                                            if ok2 then
                                                local confirmed = waitForEggRemoval(purchaseTimeout)
                                                if confirmed then
                                                    lastPurchaseConfirmed = true
                                                    print("[AutoBuySpin] Purchase confirmed for:", entityId)
                                                else
                                                    lastPurchaseConfirmed = false
                                                    print("[AutoBuySpin] Purchase not confirmed within timeout for:", entityId)
                                                end
                                            else
                                                print("[AutoBuySpin] firePurchaseEgg error after request:", tostring(err2))
                                            end
                                        else
                                            print("[AutoBuySpin] No entity id after request; skipping purchase.")
                                            -- No entity id after request; treat as no pending purchase
                                            lastPurchaseConfirmed = true
                                        end
                                    else
                                        print("[AutoBuySpin] Egg did not spawn within timeout after request.")
                                        -- If no egg spawned, clear pending purchase so we can try again
                                        lastPurchaseConfirmed = true
                                    end
                                else
                                    print("[AutoBuySpin] fireRequestEgg error:", tostring(err))
                                    -- On error, allow retry next loop
                                    lastPurchaseConfirmed = true
                                end
                            else
                                print("[AutoBuySpin] Waiting for previous purchase confirmation before requesting new egg.")
                            end
                        end
                    end)
                    wait(1)
                end
            end)
        end
    end,
})

-- Expose for external use if needed
_G.AutoBuySpinToggle = AutoBuySpinToggle
_G.GetCurrentEggInfo = function()
    local ok, info = pcall(function()
        if not currentEggTag or not currentEggTag.Parent then
            return {
                EggTag = nil,
                ParentName = nil,
                Price = nil,
                Rarity = nil,
                Variety = nil,
            }
        end
        local container = currentEggTag:FindFirstChild("Container") or currentEggTag
        return {
            EggTag = currentEggTag,
            ParentName = currentParentName,
            Price = readContainerField(container, "Price"),
            Rarity = readContainerField(container, "Rarity"),
            Variety = readContainerField(container, "Variety"),
        }
    end)
    if ok then return info end
    return {
        EggTag = nil,
        ParentName = nil,
        Price = nil,
        Rarity = nil,
        Variety = nil,
    }
end

-- Initial refresh
pcall(refreshCurrentEgg)
