-- Safely destroy any previously created Rayfield UI (put this before loading the library)
if _G.RayfieldInstance then
    pcall(function()
        if type(_G.RayfieldInstance.Destroy) == "function" then
            _G.RayfieldInstance:Destroy()
        end
    end)
    _G.RayfieldInstance = nil
end

-- Load Rayfield library and create a minimal, blank window
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/UnHub-LEGO/Scripts/refs/heads/main/Rayfield%20Library'))()
_G.RayfieldInstance = Rayfield

local Window = Rayfield:CreateWindow({
    Name = "UnHub (Blank)",
    FileName = "UnHub_Blank",
    Icon = 0,
    Theme = "DarkBlue",
    ToggleUIKeybind = "H",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnHub_Blank"
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "UnHub",
        Subtitle = "Key",
        Note = "",
        FileName = "Key",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {}
    }
})

-- Minimal UI toggle button (draggable) to show/hide Rayfield
do
    local ST = Instance.new("ScreenGui")
    local T = Instance.new("ImageButton")
    local Corner = Instance.new("UICorner")

    ST.Name = "Toggle UnHub"
    -- Parent to the same UI context Rayfield uses so it appears alongside the Rayfield UI
    -- If Rayfield:GetParent() or its parent is nil, fall back to CoreGui
    local parentGui = nil
    pcall(function()
        parentGui = Rayfield:GetParent() and Rayfield:GetParent().Parent
    end)
    if not parentGui or not parentGui:IsA("Instance") then
        parentGui = game:GetService("CoreGui")
    end
    ST.Parent = parentGui
    ST.ResetOnSpawn = false

    T.Name = "UnHubToggle"
    T.Parent = ST
    T.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    T.Position = UDim2.new(0, 30, 0.08, 0)
    T.Size = UDim2.new(0, 50, 0, 50)
    T.Image = "rbxassetid://112045743772867" -- replace with your decal id if desired
    T.Active = true
    T.Draggable = true
    T.AutoButtonColor = true

    Corner.Name = "Corner"
    Corner.Parent = T
    Corner.CornerRadius = UDim.new(0, 8)

    -- Toggle Rayfield visibility on click
    T.MouseButton1Click:Connect(function()
        local ok, enabled = pcall(function() return Rayfield:GetEnable() end)
        if ok then
            pcall(function() Rayfield:SetEnable(not enabled) end)
        end
    end)
end

-- Load (or create) configuration so Rayfield can restore UI state if needed
pcall(function() Rayfield:LoadConfiguration() end)

-- Egg Status UI (always enabled; toggle removed) + Auto Buy+Spin Eggs toggle
do
    local StatusTab = Window:CreateTab("Egg Status", 4483362458)
    local StatusSection = StatusTab:CreateSection("Spawned Egg Status")
    local StatusParagraph = StatusTab:CreateParagraph({Title = "Egg Status", Content = "Searching for spawned egg..."})

    -- Auto Buy+Spin Eggs toggle (user can enable/disable)
    local AutoBuyToggle = StatusTab:CreateToggle({
        Name = "Auto Buy+Spin Eggs",
        CurrentValue = false,
        Flag = "AutoBuySpinEggs",
        Callback = function(Value) end,
    })

    -- Always enabled status display
    local enabledStatus = true

    -- Local control for auto buy
    local autoBuyEnabled = false
    AutoBuyToggle.Callback = function(Value)
        autoBuyEnabled = Value
    end

    -- Helper to read a text-like child safely
    local function readTextOrValue(inst)
        if not inst then return nil end
        if inst:IsA("TextLabel") or inst:IsA("TextBox") or inst:IsA("TextButton") then
            return inst.Text
        end
        if inst:IsA("ValueBase") and inst.Value ~= nil then
            return tostring(inst.Value)
        end
        local ok, txt = pcall(function() return inst.Text end)
        if ok and type(txt) == "string" and txt ~= "" then return txt end
        local ok2, val = pcall(function() return inst.Value end)
        if ok2 and val ~= nil then return tostring(val) end
        return nil
    end

    -- Scans workspace for all children that contain an Eggtag and returns a table of info
    local function getAllSpawnedEggsInfo()
        local results = {}
        for _, child in pairs(workspace:GetChildren()) do
            if child and child:FindFirstChild("Eggtag") then
                local tag = child:FindFirstChild("Eggtag")
                if tag and tag:FindFirstChild("Container") then
                    local container = tag.Container
                    local price = readTextOrValue(container:FindFirstChild("Price")) or "N/A"
                    local rarity = readTextOrValue(container:FindFirstChild("Rarity")) or "N/A"
                    local variety = readTextOrValue(container:FindFirstChild("Variety")) or readTextOrValue(container:FindFirstChild("Mutation")) or "N/A"
                    local eggName = tostring(child.Name or "Unknown")
                    table.insert(results, {Name = eggName, Price = price, Rarity = rarity, Variety = variety})
                end
            end
        end
        return results
    end

    -- Formats a list of egg infos into a string for the paragraph
    local function formatEggsForDisplay(eggs)
        if not eggs or #eggs == 0 then
            return "No egg detected."
        end
        local lines = {}
        for i, e in ipairs(eggs) do
            local line = string.format("%d) Name: %s | Price: %s | Rarity: %s | Mutation: %s", i, tostring(e.Name), tostring(e.Price), tostring(e.Rarity), tostring(e.Variety))
            table.insert(lines, line)
        end
        return table.concat(lines, "\n")
    end

    -- === Locate remotes once and keep references ===
    local requestRemote, purchaseRemote
    local function locateRemotesBlocking()
        -- Use WaitForChild chain to reliably get the Instances container and remotes.
        -- This will yield until the path exists (which is usually fine at runtime).
        local ok, modules = pcall(function()
            return game:GetService("ReplicatedStorage"):WaitForChild("Modules")
        end)
        if not ok or not modules then return end

        local internals = modules:WaitForChild("Internals")
        if not internals then return end
        local skeleton = internals:WaitForChild("Skeleton")
        if not skeleton then return end
        local conduit = skeleton:WaitForChild("Conduit")
        if not conduit then return end
        local instances = conduit:WaitForChild("Instances")
        if not instances then return end

        requestRemote = instances:FindFirstChild("_requestEgg") or instances:FindFirstChild("_RequestEgg") or instances:FindFirstChild("requestEgg")
        purchaseRemote = instances:FindFirstChild("_purchaseEgg") or instances:FindFirstChild("_PurchaseEgg") or instances:FindFirstChild("purchaseEgg")
    end

    -- Try to locate remotes now (blocking). If they don't exist yet, this will wait until they do.
    pcall(function()
        locateRemotesBlocking()
    end)

    -- Helper wrappers to fire remotes safely and log result
    local function safeFireRequest()
        if not requestRemote then
            return false, "requestRemote missing"
        end
        local args = {
            {
                __raw = true,
                data = {}
            }
        }
        local ok, err = pcall(function()
            requestRemote:FireServer(unpack(args))
        end)
        return ok, err
    end

    local function safeFirePurchase(id, rarity, variety)
        if not purchaseRemote then
            return false, "purchaseRemote missing"
        end
        local args = {
            {
                __raw = true,
                data = {
                    id = id or "",
                    rarity = rarity or "",
                    variety = variety or ""
                }
            }
        }
        local ok, err = pcall(function()
            purchaseRemote:FireServer(unpack(args))
        end)
        return ok, err
    end

    -- Updater loop for status paragraph (always running)
    spawn(function()
        while true do
            if enabledStatus then
                local ok, eggs = pcall(function()
                    return getAllSpawnedEggsInfo()
                end)

                if ok and eggs and #eggs > 0 then
                    local content = formatEggsForDisplay(eggs)
                    pcall(function()
                        StatusParagraph:Set({Title = "Egg Status", Content = content})
                    end)
                else
                    pcall(function()
                        StatusParagraph:Set({Title = "Egg Status", Content = "No egg detected."})
                    end)
                end
            end
            wait(0.5)
        end
    end)

    -- Auto Buy+Spin Eggs loop (robust firing logic)
    spawn(function()
        local cycleDelay = 1.2 -- delay between full cycles (seconds)
        while true do
            if autoBuyEnabled then
                -- Ensure remotes are present; try to locate again if missing
                if not requestRemote or not purchaseRemote then
                    pcall(function()
                        locateRemotesBlocking()
                    end)
                end

                -- 1) Check for existing eggs in workspace
                local eggs = {}
                pcall(function() eggs = getAllSpawnedEggsInfo() end)

                if eggs and #eggs > 0 then
                    -- If an egg exists, attempt to purchase it
                    local target = eggs[1]
                    local id = target.Name
                    local rarity = target.Rarity
                    local variety = target.Variety

                    if not purchaseRemote then
                        pcall(function()
                            StatusParagraph:Set({Title = "Egg Status", Content = "Purchase remote not found; retrying locate..."})
                        end)
                        -- try locating again but don't block too long
                        pcall(function()
                            locateRemotesBlocking()
                        end)
                        wait(0.2)
                    end

                    if purchaseRemote then
                        local ok, err = safeFirePurchase(id, rarity, variety)
                        if ok then
                            pcall(function()
                                StatusParagraph:Set({Title = "Egg Status", Content = ("Fired purchase for: %s | Rarity: %s | Variety: %s"):format(tostring(id), tostring(rarity), tostring(variety))})
                            end)
                        else
                            pcall(function()
                                StatusParagraph:Set({Title = "Egg Status", Content = ("Purchase FireServer failed: %s"):format(tostring(err))})
                            end)
                        end
                        -- Give server time to process purchase and to avoid immediate re-purchase
                        wait(1.0)
                    else
                        -- Can't purchase; wait a bit before retrying
                        wait(1.5)
                    end
                else
                    -- No egg present: request a new egg once, then poll for it
                    if not requestRemote then
                        pcall(function()
                            StatusParagraph:Set({Title = "Egg Status", Content = "Request remote not found; retrying locate..."})
                        end)
                        pcall(function()
                            locateRemotesBlocking()
                        end)
                        wait(0.2)
                    end

                    if requestRemote then
                        local ok, err = safeFireRequest()
                        if ok then
                            pcall(function()
                                StatusParagraph:Set({Title = "Egg Status", Content = "Requested new egg, waiting for spawn..."})
                            end)
                        else
                            pcall(function()
                                StatusParagraph:Set({Title = "Egg Status", Content = ("Request FireServer failed: %s"):format(tostring(err))})
                            end)
                            -- If request failed, wait and retry later
                            wait(1.5)
                            continue
                        end
                    else
                        pcall(function()
                            StatusParagraph:Set({Title = "Egg Status", Content = "Request remote not found; cannot spawn egg."})
                        end)
                        wait(2.0)
                        continue
                    end

                    -- After requesting, poll for the spawned egg (short timeout)
                    local found = false
                    local timeout = 3.0
                    local elapsed = 0
                    local pollInterval = 0.12
                    while elapsed < timeout do
                        wait(pollInterval)
                        elapsed = elapsed + pollInterval
                        local newEggs = {}
                        pcall(function() newEggs = getAllSpawnedEggsInfo() end)
                        if newEggs and #newEggs > 0 then
                            -- Ensure the egg has meaningful fields (sometimes the billboard spawns but text updates later)
                            local first = newEggs[1]
                            if first.Rarity and first.Rarity ~= "N/A" and first.Variety and first.Variety ~= "N/A" then
                                found = true
                                break
                            end
                            -- If fields are "N/A", keep polling a bit longer
                        end
                    end

                    if not found then
                        pcall(function()
                            StatusParagraph:Set({Title = "Egg Status", Content = "No fully-initialized egg detected after request."})
                        end)
                        -- small delay before next cycle to avoid spamming
                        wait(1.0)
                    else
                        -- On next cycle the purchase branch will pick it up and attempt purchase
                        wait(0.1)
                    end
                end

                -- End of cycle delay
                wait(cycleDelay)
            else
                wait(0.25)
            end
        end
    end)
end
